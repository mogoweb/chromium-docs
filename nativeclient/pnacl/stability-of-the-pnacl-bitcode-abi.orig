<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="http://schema.org/WebPage">
<head>
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<script type="text/javascript">/* Copyright 2008 Google. */ (function() { var e="wtsrt_",g="tbsd_",h="tbnd_",k="start",l="_wtsrt",m="_tbnd",n="CSI/";(function(){function f(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp(n+a)}catch(d){}};this.tick(k,null,a)}var a;window.performance&&(a=window.performance.timing);var p=a?new f(a.responseStart):new f;window.jstiming={Timer:f,load:p};if(a){var c=a.navigationStart,d=a.responseStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick(l,void 0,c),b.tick(e,l,d),b.tick(g,e))}try{a=null,
window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick(m,void 0,window.chrome.csi().startE),b.tick(h,m,c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick(m,void 0,window.external.startE),b.tick(h,m,c))),a&&(window.jstiming.pt=a)}catch(q){}})(); })()
</script>
<link rel="shortcut icon" href="/_/rsrc/1354323194313/favicon.ico" type="image/x-icon" />
<link rel="apple-touch-icon" href="http://www.gstatic.com/sites/p/56e332/system/app/images/apple-touch-icon.png" type="image/png" />
<script type="text/javascript">/* Copyright 2008 Google. */ (function() { var d="",g="__duration__",h="function";function k(c){return document.getElementById(c)}window.byId=k;function l(c){return c.replace(/^\s+|\s+$/g,d)}window.trim=l;var m=[],n=0;window.JOT_addListener=function(c,a,b){var e=new String(n++);c={eventName:c,handler:a,compId:b,key:e};m.push(c);return e};window.JOT_removeListenerByKey=function(c){for(var a=0;a<m.length;a++)if(m[a].key==c){m.splice(a,1);break}};
window.JOT_removeAllListenersForName=function(c){for(var a=0;a<m.length;a++)m[a].eventName==c&&m.splice(a,1)};window.JOT_postEvent=function(c,a,b){var e={eventName:c,eventSrc:a||{},payload:b||{}};if(window.JOT_fullyLoaded)for(a=m.length,b=0;b<a&&b<m.length;b++){var f=m[b];f&&f.eventName==c&&(e.listenerCompId=f.compId||d,(f=typeof f.handler==h?f.handler:window[f.handler])&&f(e))}else window.JOT_delayedEvents.push({eventName:c,eventSrc:a,payload:b})};window.JOT_delayedEvents=[];
window.JOT_fullyLoaded=!1;window.JOT_formatRelativeToNow=function(c,a){var b=((new Date).getTime()-c)/6E4;if(1440<=b||0>b)return null;var e=0;60<=b&&(b/=60,e=2);2<=b&&e++;return a?window.JOT_siteRelTimeStrs[e].replace(g,Math.floor(b)):window.JOT_userRelTimeStrs[e].replace(g,Math.floor(b))}; })()
</script>
<script>

  

  var breadcrumbs = [{"path":"/nativeclient","deleted":false,"title":"Native Client","dir":"ltr"},{"path":"/nativeclient/pnacl","deleted":false,"title":"PNaCl","dir":"ltr"},{"path":"/nativeclient/pnacl/stability-of-the-pnacl-bitcode-abi","deleted":false,"title":"Stability of the PNaCl bitcode ABI","dir":"ltr"}];
  var JOT_clearDotPath = 'http://www.gstatic.com/sites/p/56e332/system/app/images/cleardot.gif';

  
  var JOT_userRelTimeStrs = ["a minute ago","__duration__ minutes ago","an hour ago","__duration__ hours ago"];

  
  

  

  var webspace = {"enableAnalytics":true,"pageSharingId":"jotspot_page","enableUniversalAnalytics":false,"sharingPolicy":"OPENED_WITH_INDICATOR","siteTitle":"The Chromium Projects","isStartPageEnabled":true,"adsensePublisherId":null,"features":{"languageSelectDefaultTextSetToDefault":true,"validateClientGvizDataSourceUrls":true,"moreMobileStyleImprovements":true,"newInsertMenuIcons":true,"accessibleSortingButtons":true,"domainAnalyticsInGAOnly":true,"noCaptcha":true,"fileCabinetScreenReaderFix":true,"updatedTosAndPrivacyLinks":null,"pageDrafts":false,"mobileOrientationFix":true,"plusBadge":false,"pdfEmbedSupport":false,"jsClickFix":true},"isPublic":true,"isConsumer":false,"serverFlags":{"cajaBaseUrl":"//www.gstatic.com/caja","cajaDebugMode":false},"onepickBaseUrl":"https://docs.google.com","domainAnalyticsAccountId":"","plusPageId":"","signInUrl":"https://www.google.com/a/SelectSession?continue\u003dhttp://sites.google.com/a/chromium.org/dev/nativeclient/pnacl/stability-of-the-pnacl-bitcode-abi\u0026service\u003djotspot","analyticsAccountId":"UA-5484340-1","scottyUrl":"/_/upload","homePath":"/","siteNoticeUrlEnabled":null,"plusPageUrl":"","adsensePromoClickedOrSiteIneligible":true,"csiReportUri":"http://csi.gstatic.com/csi","sharingId":"jotspot","termsUrl":"//www.google.com/intl/en/policies/terms/","gvizVersion":1,"editorResources":{"sitelayout":["http://www.gstatic.com/sites/p/56e332/system/app/css/sitelayouteditor.css"],"text":["http://www.gstatic.com/sites/p/56e332/system/js/codemirror.js","http://www.gstatic.com/sites/p/56e332/system/app/css/codemirror_css.css","http://www.gstatic.com/sites/p/56e332/system/js/trog_edit__en.js","http://www.gstatic.com/sites/p/56e332/system/app/css/trogedit.css","/_/rsrc/1441580320000/system/app/css/editor.css","http://www.gstatic.com/sites/p/56e332/system/app/css/codeeditor.css","/_/rsrc/1441580320000/system/app/css/camelot/editor-jfk-wlb.css"]},"sharingUrlPrefix":"/_/sharing","isAdsenseEnabled":true,"domain":"chromium.org","baseUri":"","name":"dev","siteTemplateId":false,"siteNoticeRevision":null,"siteNoticeUrlAddress":null,"siteNoticeMessage":null,"page":{"isRtlLocale":false,"canDeleteWebspace":null,"isPageDraft":null,"parentPath":"/nativeclient/pnacl","parentWuid":"wuid:gx:1c9f2315777aacf6","siteLocale":"en","timeZone":"America/Los_Angeles","type":"text","title":"Stability of the PNaCl bitcode ABI","locale":"en","wuid":"wuid:gx:17f008e7931f659f","revision":3,"path":"/nativeclient/pnacl/stability-of-the-pnacl-bitcode-abi","isSiteRtlLocale":false,"pageInheritsPermissions":null,"name":"stability-of-the-pnacl-bitcode-abi","canChangePath":true,"state":"","properties":{},"bidiEnabled":false,"currentTemplate":{"path":"/system/app/pagetemplates/text","title":"Web Page"}},"canPublishScriptToAnyone":true,"user":{"keyboardShortcuts":true,"sessionIndex":"","guest_":true,"displayNameOrEmail":"guest","userName":"guest","uid":"","renderMobile":false,"domain":"","namespace":"","hasWriteAccess":false,"namespaceUser":false,"primaryEmail":"guest","hasAdminAccess":false},"gadgets":{"baseUri":"/system/app/pages/gadgets"}};
  webspace.page.breadcrumbs = breadcrumbs;

  
  var JOT_siteRelTimeStrs = ["a minute ago","__duration__ minutes ago","an hour ago","__duration__ hours ago"];

</script>
<script type="text/javascript">
                window.jstiming.load.tick('scl');
              </script>
<meta name="title" content="Stability of the PNaCl bitcode ABI - The Chromium Projects" />
<meta itemprop="name" content="Stability of the PNaCl bitcode ABI - The Chromium Projects" />
<meta property="og:title" content="Stability of the PNaCl bitcode ABI - The Chromium Projects" />
<meta name="description" content="Home of the Chromium Open Source Project" />
<meta itemprop="description" content="Home of the Chromium Open Source Project" />
<meta id="meta-tag-description" property="og:description" content="Home of the Chromium Open Source Project" />
<style type="text/css">
</style>
<link rel="stylesheet" type="text/css" href="http://www.gstatic.com/sites/p/56e332/system/app/themes/beigeandblue/standard-css-beigeandblue-ltr-ltr.css" />
<link rel="stylesheet" type="text/css" href="/_/rsrc/1441580320000/system/app/css/overlay.css?cb=beigeandblueundefineda100%25%25150goog-ws-leftthemedefaultstandard" />
<link rel="stylesheet" type="text/css" href="/_/rsrc/1441580320000/system/app/css/camelot/allthemes-view.css" />
<!--[if IE]>
          <link rel="stylesheet" type="text/css" href="/system/app/css/camelot/allthemes%2die.css" />
        <![endif]-->
<title>Stability of the PNaCl bitcode ABI - The Chromium Projects</title>
<meta itemprop="image" content="/_/rsrc/1438879449147/config/customLogo.gif?revision=3" />
<meta property="og:image" content="/_/rsrc/1438879449147/config/customLogo.gif?revision=3" />
<script type="text/javascript">
                window.jstiming.load.tick('cl');
              </script>
</head>
<body xmlns="http://www.google.com/ns/jotspot" id="body" class=" en            ">
<div id="sites-page-toolbar" class="sites-header-divider">
<div xmlns="http://www.w3.org/1999/xhtml" id="sites-status" class="sites-status" style="display:none;"><div id="sites-notice" class="sites-notice" role="status" aria-live="assertive"> </div></div>
</div>
<div id="sites-chrome-everything-scrollbar">
<div id="sites-chrome-everything" class="">
<div id="sites-chrome-page-wrapper" style="direction: ltr">
<div id="sites-chrome-page-wrapper-inside">
<div xmlns="http://www.w3.org/1999/xhtml" id="sites-chrome-header-wrapper" style="height:auto;">
<table id="sites-chrome-header" class="sites-layout-hbox" cellspacing="0" style="height:auto;">
<tr class="sites-header-primary-row" id="sites-chrome-userheader">
<td id="sites-header-title" class="" role="banner"><div class="sites-header-cell-buffer-wrapper"><a href="http://www.chromium.org/" id="sites-chrome-userheader-logo"><img id="logo-img-id" src="/_/rsrc/1438879449147/config/customLogo.gif?revision=3" alt="The Chromium Projects" class="sites-logo  " /></a><h2><a href="http://www.chromium.org/" dir="ltr" id="sites-chrome-userheader-title">The Chromium Projects</a></h2></div></td><td class="sites-layout-searchbox  "><div class="sites-header-cell-buffer-wrapper"><form id="sites-searchbox-form" action="/system/app/pages/search" role="search"><input type="hidden" id="sites-searchbox-scope" name="scope" value="search-site" /><input type="text" id="jot-ui-searchInput" name="q" size="20" value="" aria-label="Search this site" /><div id="sites-searchbox-button-set" class="goog-inline-block"><div role="button" id="sites-searchbox-search-button" class="goog-inline-block jfk-button jfk-button-standard" tabindex="0">Search this site</div></div></form></div></td>
</tr>
<tr class="sites-header-secondary-row" id="sites-chrome-horizontal-nav">
<td colspan="2" id="sites-chrome-header-horizontal-nav-container" role="navigation">
</td>
</tr>
</table>
</div>
<div id="sites-chrome-main-wrapper">
<div id="sites-chrome-main-wrapper-inside">
<table id="sites-chrome-main" class="sites-layout-hbox" cellspacing="0" cellpadding="{scmCellpadding}" border="0">
<tr>
<td id="sites-chrome-sidebar-left" class="sites-layout-sidebar-left initial" style="width:150px">
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_7648876402527094" class="sites-embed" role="navigation"><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotId="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="/chromium-projects" jotId="wuid:gx:10ae433dadbbab13" class="sites-navigation-link">Home</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="/Home" jotId="wuid:gx:43582b9d2029d3af" class="sites-navigation-link">Chromium</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="/chromium-os" jotId="wuid:gx:83df2ab1f8880ba" class="sites-navigation-link">Chromium OS</a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_14720868319272995" class="sites-embed" role="navigation"><h4 class="sites-embed-title">Quick links</h4><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotId="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="http://www.chromium.org/for-testers/bug-reporting-guidelines" class="sites-navigation-link">Report bugs</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="http://www.chromium.org/developers/discussion-groups" class="sites-navigation-link">Discuss</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="/system/app/pages/sitemap/hierarchy" jotId="wuid:gx:4b58a9a350ad12f" class="sites-navigation-link">网站地图</a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_19690813310444355" class="sites-embed" role="navigation"><h4 class="sites-embed-title">Other sites</h4><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotId="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="http://blog.chromium.org/" class="sites-navigation-link">Chromium Blog</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="http://code.google.com/chrome/extensions/" class="sites-navigation-link">Google Chrome Extensions</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="https://developers.google.com/chrome/chrome-frame/" class="sites-navigation-link">Google Chrome Frame</a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_19695218559354544" class="sites-embed" role="complementary"><h4 class="sites-embed-title"></h4><div class="sites-embed-content sites-embed-content-sidebar-textbox"><div dir="ltr"><span style="font-size:x-small">Except as otherwise </span><a href="http://developers.google.com/site-policies.html#restrictions"><span style="font-size:x-small">noted</span></a><span style="font-size:x-small">, the content of this page is licensed under a </span><a href="http://creativecommons.org/licenses/by/2.5/"><span style="font-size:x-small">Creative Commons Attribution 2.5 license</span></a><span style="font-size:x-small">, and examples are licensed under the </span><a href="http://src.chromium.org/viewvc/chrome/trunk/src/LICENSE" target="_blank"><span style="font-size:x-small">BSD License</span></a><span style="font-size:x-small">.<br /></span></div></div></div>
</td>
<td id="sites-canvas-wrapper">
<div id="sites-canvas" role="main">
<div id="goog-ws-editor-toolbar-container"> </div>
<div xmlns="http://www.w3.org/1999/xhtml" id="title-crumbs" style="">
<A href="/nativeclient" dir="ltr">Native Client</A>‎ &gt; ‎<A href="/nativeclient/pnacl" dir="ltr">PNaCl</A>‎ &gt; ‎
  </div>
<h3 xmlns="http://www.w3.org/1999/xhtml" id="sites-page-title-header" style="" align="left">
<span id="sites-page-title" dir="ltr" tabindex="-1" style="outline: none">Stability of the PNaCl bitcode ABI</span>
</h3>
<div id="sites-canvas-main" class="sites-canvas-main">
<div id="sites-canvas-main-content">
<table xmlns="http://www.w3.org/1999/xhtml" cellspacing="0" class="sites-layout-name-one-column sites-layout-hbox"><tbody><tr><td class="sites-layout-tile sites-tile-name-content-1"><div dir="ltr"><div style="font-size:12.727272033691406px;direction:ltr;margin:5px 0px 0px 15px;padding-bottom:5px;color:rgb(34,34,34);font-family:arial,sans-serif"><div style="overflow:hidden"><div dir="ltr"><div>More up to date documentation is available at: <a href="http://developer.chrome.com/native-client/overview">http://developer.chrome.com/native-client/overview</a></div></div></div></div><div style="font-size:12.727272033691406px;direction:ltr;margin:5px 15px 0px 0px;padding-bottom:5px;color:rgb(34,34,34);font-family:arial,sans-serif"><div style="overflow:hidden"><div dir="ltr"><div><br /></div><div><br /></div><div>Stability of the PNaCl bitcode ABI</div><div><br /></div><div><br /></div><div>Document version: 0.1 (June 17th, 2013)</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div>Introduction</div><div>What is meant by ABI stability</div><div>The scope of this document</div><div>PNaCl changes not related to bitcode stability</div><div>Goals</div><div>Challenges for bitcode ABI stability</div><div>Approaches to maintaining backwards compatibility of bitcode</div><div>Approach #1: a single supported bitcode version</div><div>Approach #2: evolving the stable bitcode over time, while maintaining backwards compatibility</div><div>Approach #3: hybrid between #1 and #2</div><div>Steps towards a stable bitcode ABI</div><div>Stripping LLVM metadata</div><div>Rewriting vararg calls</div><div>Expanding constant expressions</div><div>Strip fastcc-related attributes</div><div>Strip system-specific function attributes</div><div>Disallow inline assembly</div><div>Only allow whitelisted intrinsics and external symbols</div><div>Restrict integer arguments and return values to at least i32</div><div>Fixed TLS layout for PNaCl</div><div>Restrict usage of structs, arrays and pointers in the stable bitcode</div><div>Concrete proposal details</div><div>Handling getelementptr</div><div>Handling global initializers</div><div>Define __{init|fini}_array_{start|end} at bitcode creation time</div><div>C++ exception handling ABI</div><div>Untrusted Fault Handling</div><div>Memory Model, Atomics, Fences</div><div>Syscalls</div><div>C11/C++11</div><div>Memory Ordering</div><div>Volatile</div><div>Undefined Behavior</div><div>Specification</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div>Introduction</div><div><br /></div><div><br /></div><div>The goal of this document is to define the PNaCl stable bitcode ABI for the first release of Chrome in which PNaCl is enabled for the open web. This will be the first release in which PNaCl starts guaranteeing ABI stability.</div><div><br /></div><div><br /></div><div>What is meant by ABI stability</div><div><br /></div><div><br /></div><div>ABI stability for PNaCl bitcode means the guarantee of backwards compatibility - described by the following scenario:</div><div>1. A developer creates a PNaCl application and places it online. The application is a .pexe generated with the toolchain of Chrome release M.</div><div>2. At some point in the future, a user wants to run the .pexe with Chrome release N (with N &gt;= M).</div><div>3. Even though the PNaCl translator distributed with Chrome has likely changed between releases M and N, we guarantee that the .pexe continues working in the new release.</div><div>Conversely, the related issue of forward compatibility is avoided by explicitly refusing to load newer bitcode versions in older Chrome translators, as follows:</div><div>1. As before, a user generates a .pexe with Chrome release M and places it online.</div><div>2. A user tries to run the .pexe with Chrome release K with K &lt; M. Note that this only happens if the user didn’t update Chrome, which is unlikely.</div><div>3. The PNaCl translator reads the bitcode version from the .pexe and sees it’s a newer version than it supports. The translator refuses to load the .pexe and emits an error message.</div><div><br /></div><div><br /></div><div>The scope of this document</div><div><br /></div><div><br /></div><div>This document aims to define the requirement for PNaCl bitcode ABI compatibility, and lay out the steps we plan to undertake to reach a stable ABI. The goal here is not to provide a reference documentation of the ABI, but rather to facilitate discussion within the team and write down our collective thoughts on the subject.</div><div>________________</div><div>PNaCl changes not related to bitcode stability</div><div><br /></div><div><br /></div><div>PNaCl also has differences from standard LLVM targets which are unrelated to bitcode stability. These are generally beyond the scope of this document, but to summarize, they fall into 2 categories: 1) those related to portability across architectures, and 2) those related to Native Client and its security sandboxing model.</div><div><br /></div><div><br /></div><div>For example, the architecture is defined as “le32” indicating that the architecture is a generic little-endian machine with 32-bit pointers.  The target triple is le32-unknown-nacl, and the compiler #defines __pnacl__ when the architecture is le32 and __native_client__ when the OS is NaCl. The data model is ILP32, which means that ints, pointers, and longs are all 32 bits wide.</div><div><br /></div><div><br /></div><div>Additionally, clang’s ABI lowering for calling conventions is different from that used by hardware architectures (because they are different from each other, even for the same C types). There are a few additional restrictions on PNaCl programs such as that they may only use IEEE floating-point types.</div><div><br /></div><div><br /></div><div>The use of Native Client to securely sandbox PNaCl code also imposes some restrictions on programs: however the details of the sandbox implementation are subject to change and should not generally be exposed to developers.</div><div>________________</div><div><br /></div><div><br /></div><div>Goals</div><div><br /></div><div><br /></div><div>The main and obvious goal of PNaCl bitcode ABI stability is to support backwards compatibility of PNaCl bitcode. As the section above describes, it’s essential to allow existing bitcode placed online to run on newer versions of Chrome. This is similar to any standard-abiding web platform application (HTML+CSS+JS) that is expected to keep working in newer browsers.</div><div><br /></div><div><br /></div><div>An additional goal is to define a smaller and simpler subset of the LLVM IR for PNaCl bitcode. A smaller and simpler subset is easier to test and validate. Furthermore, if an alternative fast code generator for PNaCl is ever considered, such a subset will be easier to implement.</div><div><br /></div><div><br /></div><div>Initially, the goal of this document is to help deciding which subset of the LLVM IR will be part of the PNaCl bitcode ABI in the first public release.</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div>Challenges for bitcode ABI stability</div><div><br /></div><div><br /></div><div>As the introduction above explains, we aim to define a stable ABI that will enable a “new” translator to read “old” bitcode successfully and compile it to native code that is validated and executed on the user’s machine. Further, we want to benefit from advances in LLVM technology and use progressively newer LLVM releases for future versions of the PNaCl translator.</div><div>On the other hand, our usage of LLVM IR as the portable representation for PNaCl implies that we’re dealing with a changing compiler IR that doesn’t have stability as one of its declared goals.</div><div><br /></div><div><br /></div><div>As a more concrete example: assuming we “freeze” the bitcode ABI on LLVM release 3.3 (which is due sometime in June 2013), in a future PNaCl translator release we’ll want to use the up-to-date LLVM, say 4.0. There’s a very high probability that LLVM IR will change between 3.3 and 4.0 to the extent that a bitcode reader from LLVM 4.0 won’t be able to read IR generated by the front-end of LLVM 3.3.</div><div><br /></div><div><br /></div><div>This incompatibility in IR between LLVM releases manifests in three ways:</div><div>1. Semantic changes in IR. For example: type system rewrite in 3.0, attribute changes in 3.3, possible future removal of IR instructions.</div><div>2. Changes in binary LLVM bitcode encoding.</div><div>3. “Silent” change in bitcode usage between passes that occur before and after pexe creation. As PNaCl uses a newer LLVM, the pexe will have been created with an older version which might emit bitcode that now looks odd to newer LLVM, hindering optimizations or exposing bugs that do not exist in upstream LLVM (where the bitcode never goes out of sync).</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div>Approaches to maintaining backwards compatibility of bitcode</div><div><br /></div><div><br /></div><div>This discussion knowingly ignores the option where we fork LLVM from some given version and maintain our own “stable” version of it for PNaCl. In other words, it’s assumed that the LLVM backend (code generation and emission) keeps evolving in the PNaCl translator.</div><div><br /></div><div><br /></div><div>Approach #1: a single supported bitcode version</div><div><br /></div><div><br /></div><div>We define a stable bitcode in the first public release of PNaCl. This is the bitcode that all subsequent releases will generate.</div><div><br /></div><div><br /></div><div>Pros:</div><div>1. Only a single version of the bitcode reader is required. Each version of the translator will have to convert this stable bitcode to its up-to-date in-memory representation for consumption in the backend.</div><div>2. Provides forward-compatibility to some extent. Since future PNaCl front-ends will continue generating the stable bitcode, older translators will be able to read them as well.</div><div>Cons:</div><div>1. If future versions of LLVM add new features to the IR that we want to provide as part of PNaCl, we will have to backport upstream’s BitcodeReader/BitcodeWriter changes to PNaCl’s copy of the bitcode reader/writer.  This might get harder if upstream’s bitcode reader/writer diverges.</div><div>2. Requires more maintenance of the PNaCl frontend, assuming that we want to keep following the advances in bug fixes in Clang. Newer versions of Clang will generate newer IR, which we’ll have to “cut down” to the stable subset. Note that some changes (such as rewrites or removal of instructions) may be non-trivial.</div><div><br /></div><div><br /></div><div>________________</div><div><br /></div><div><br /></div><div>Approach #2: evolving the stable bitcode over time, while maintaining backwards compatibility</div><div><br /></div><div><br /></div><div>As with approach #1, we define a stable bitcode in the first public release of PNaCl. However, in future releases we may change the bitcode ABI, as long as we ensure that newer translators can still read older bitcode formats.</div><div><br /></div><div><br /></div><div>Pros:</div><div>1. We can enjoy advances in LLVM in the future. For example, new features that get added to the IR and aid optimizations.</div><div>2. Easier to follow upstream Clang in the PNaCl front-end. If Clang changes the bitcode it generates in significant ways, we can incorporate these changes into the new stable bitcode ABI.</div><div>Cons:</div><div>1. This approach requires maintaining N bitcode readers: one per supported bitcode version. The translator will have to recognize the bitcode version and apply the appropriate reader that knows how to translate that version of the bitcode into the new translator in-memory structures.</div><div>1. We will have to maintain N readers.  If LLVM’s C++ API for building in-memory IR changes, we will have to backport upstream changes to N bitcode readers.</div><div>2. This will increase the size of the PNaCl translator.</div><div>1. Forward compatibility is impossible in this approach since older translators won’t be able to read new .pexes. This isn’t a big issue if we assume PNaCl auto-updates like Chrome does. This can be mitigated with an SDK option to target older PNaCl versions.</div><div><br /></div><div><br /></div><div>Approach #3: hybrid between #1 and #2</div><div><br /></div><div><br /></div><div>Since there is currently a large unknown with regards to the changes LLVM and Clang may undergo in the near and far future, it may make sense to start with approach #1, keeping the option to switch to #2 at some point.</div><div>It’s crucial that we guarantee backwards compatibility by always being able to read and translate the bitcode generated by the first public release of PNaCl. Whether we’ll allow newer versions of this bitcode to also be generated and read by future toolchains is an implementation detail that should be transparent to developers and users.</div><div><br /></div><div><br /></div><div> </div><div>________________</div><div><br /></div><div><br /></div><div>Steps towards a stable bitcode ABI</div><div><br /></div><div><br /></div><div>The PNaCl portable bitcode is based on LLVM IR. For the sake of defining a stable bitcode ABI, a number of simplifications and restrictions have to be applied to LLVM IR in order to synthesize a subset that can remain stable over time. </div><div><br /></div><div><br /></div><div>The optimizers will generally work best if they are allowed to operate on the current version of the IR in its full generality; therefore the general plan is to run Clang and the target-independent optimizations first, and then transform their output into the stable subset in a final phase called ABI legalization.</div><div><br /></div><div><br /></div><div>On the translator side, a step called “ABI verification” is performed. This verifies that the downloaded .pexe conforms to the PNaCl bitcode ABI. The verifier is the “ultimate source of truth” for what is and what isn’t part of the bitcode ABI. A snapshot of its current implementation is available online:<a href="http://git.chromium.org/gitweb/?p=native_client/pnacl-llvm.git;a=tree;f=lib/Analysis/NaCl" style="color:rgb(17,85,204)" target="_blank">http://git.chromium.org/gitweb/?p=native_client/pnacl-llvm.git;a=tree;f=lib/Analysis/NaCl</a></div><div><br /></div><div><br /></div><div>The following sections describe the concrete ABI legalization steps we are considering. It also attempts to provide reasons in favor and against these transformations. An implicit argument against all transformations is the engineering effort required to implement and maintain them (which includes reviewing and testing with each LLVM merge). On the other hand, an implicit argument in favor of any simplification is reduced exposure to changes in the bitcode semantics upstream; only changes in parts of the IR that are accepted as stable would require using one of the backward compatibility approaches above. The other benefit of simpler IR is that it may allow simplification of the translator. This could allow the translator to be smaller and/or faster, and also have a reduced testing and attack surface. Even though we validate and run the translator itself in a NaCl sandbox, fewer supported IR features means fewer potentially exploitable bugs that may break one of the security layers.</div><div><br /></div><div><br /></div><div>Note: regarding Challenges for bitcode ABI stability, this section will focus on the semantic aspects of LLVM IR, ignoring the issue of binary encoding.</div><div>________________</div><div>Stripping LLVM metadata</div><div><br /></div><div><br /></div><div>Description: LLVM metadata describes constructs like debug information and optimization hints (for example TBAA and branch weights). By design, metadata is inherently unstable and has undergone considerable semantic and structural changes in the past. Metadata should be stripped from .pexes and not be part of the stable ABI.</div><div><br /></div><div><br /></div><div>Note: we may consider adding back specific kinds of metadata in the future in order to support some forms of debug information (especially to reconstruct stack traces to give developers better user crash dumps) and/or aid certain optimizations.</div><div><br /></div><div><br /></div><div>Issue: <a href="https://code.google.com/p/nativeclient/issues/detail?id=3348" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=3348</a></div><div><br /></div><div><br /></div><div>Pros:</div><div>1. The inherent instability of metadata makes it a very improbable candidate for inclusion into the stable ABI.</div><div>2. Reduction of .pexe size.</div><div>3. Reduction of the test surface of the translator - we can avoid testing its handling of metadata.</div><div><br /></div><div><br /></div><div>Cons:</div><div>1. For debug metadata, this forces a slightly more complex flow of development. We want debug metadata to be stripped from .pexes by default, even if the developer initially compiled his C/C++ code with -g.</div><div>2. For optimization hints, this may cause the translator to miss some optimizations. This is, however, questionable: IR-level optimizations are done before the .pexe is generated, and in practice we didn’t observe difference in the translation result with and without TBAA metadata.</div><div>3. No stack traces on crash.</div><div>4. Developer-side incompatibilities are still a problem (may need to do clean rebuilds after toolchain switch, and there is no clear error message when there are incompatibilities).</div><div>________________</div><div>Rewriting vararg calls</div><div><br /></div><div><br /></div><div>Description: Functions that accept variable arguments and calls to them should be replaced with a scheme where the arguments are explicitly packed in a buffer (allocated by the caller). A pointer to this buffer will be passed into the function instead of the variable argument list. va_* instructions and intrinsics within the function will be rewritten to read the arguments from the explicit buffer.</div><div><br /></div><div><br /></div><div>Issue: <a href="https://code.google.com/p/nativeclient/issues/detail?id=3338" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=3338</a></div><div><br /></div><div><br /></div><div>Pros:</div><div>1. vararg calls are tricky to implement and aren’t fully supported by the LLVM backend for all architectures.</div><div>2. This transformation simplifies the ABI while being safe because there are no vararg calls from PNaCl bitcode to native code.</div><div>3. This could provide some performance improvements:</div><div>1. “opt” can sometimes better optimise explicit buffer-passing than varargs calls.</div><div>2. On x86-64, a varargs function no longer has to spill all arguments to the stack.</div><div>Cons:</div><div>1. Produced bitcode will be larger due to the explicit argument packing and unpacking. However, the effect isn’t likely to be large due to the low number of vararg functions and calls in typical code.</div><div>2. Calling a varargs function without it being declared with a C function prototype will produce code that doesn’t work.</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div>________________</div><div>Expanding constant expressions</div><div><br /></div><div><br /></div><div>Description: LLVM supports the concept of constant expressions (expressions involving other constants) that can be used as arguments to instructions. Constant expressions should be expanded to an explicit sequence of equivalent LLVM instructions.</div><div>For handling of constexprs in the context of global initializers, see Restrict usage of structs, arrays and pointers in the stable bitcode.</div><div><br /></div><div><br /></div><div>Issue: <a href="https://code.google.com/p/nativeclient/issues/detail?id=3337" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=3337</a></div><div><br /></div><div><br /></div><div>Pros:</div><div>1. Simplifies the bitcode.</div><div>1. Each LLVM instruction will represent a small unit of computation, rather than the arbitrarily many computations that are introduced by nested constant expressions. </div><div><br /></div><div><br /></div><div>Cons:</div><div>1. Increased bitcode size. Initial measurements show that this change has slightly increased the size of gzipped bitcode. See the issue for more details.</div><div>2. Impact on performance: we haven’t noticed a measurable impact on performance.</div><div><br /></div><div><br /></div><div>________________</div><div><br /></div><div><br /></div><div>Strip fastcc-related attributes</div><div><br /></div><div><br /></div><div>Description: the fastcc calling convention in LLVM is target-dependent, devised to speed up internal function calls by passing arguments in registers even on architectures where the standard calling convention does not do so (e.g. 32-bit x86). Calling convention specifications (and a related inreg parameter attribute) should be stripped from the bitcode.</div><div>Instead, we can mark all compatible internal functions fastcc explicitly in the translator for x86-32.</div><div><br /></div><div><br /></div><div>Issue: <a href="https://code.google.com/p/nativeclient/issues/detail?id=2346" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=2346</a></div><div><br /></div><div><br /></div><div>Pros:</div><div>1. We don’t gain from having this hint applied in the front-end. We can simplify the ABI by not supporting it, and instead mark the calling convention internally for architectures where it makes sense (x86-32 in this case).</div><div><br /></div><div><br /></div><div>Strip system-specific function attributes</div><div><br /></div><div><br /></div><div>Description: strip some system-specific function attributes, like naked and alignstack.</div><div><br /></div><div><br /></div><div>Issue: <a href="https://code.google.com/p/nativeclient/issues/detail?id=3415" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=3415</a></div><div><br /></div><div><br /></div><div>Pros:</div><div>1. Such attributes don’t make sense in a stable platform-independent ABI.</div><div>Disallow inline assembly</div><div><br /></div><div><br /></div><div>Description: Since inline assembly is inherently non-portable, we should reject bitcode with inline assembly in it. It will not be part of the stable ABI.</div><div><br /></div><div><br /></div><div>Issue: <a href="https://code.google.com/p/nativeclient/issues/detail?id=3126" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=3126</a>, <a href="https://code.google.com/p/nativeclient/issues/detail?id=2345" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=2345</a></div><div><br /></div><div><br /></div><div>Pros:</div><div>1. Inline assembly is non-portable.</div><div>Cons:</div><div>1. No inline assembly, even if the original code has preprocessor macros for many target platforms.</div><div>Only allow whitelisted intrinsics and external symbols</div><div><br /></div><div><br /></div><div>Description: Only intrinsic functions that are known to exist (and correctly implemented by the backend) across all platforms should be callable from bitcode. Also, only external symbols that we know are provided by the NaCl runtime should be allowed.</div><div><br /></div><div><br /></div><div>Initial whitelist for intrinsics:</div><div>1. <a href="http://llvm.nacl.read.tp/" style="color:rgb(17,85,204)" target="_blank">llvm.nacl.read.tp</a> for thread pointer.</div><div>2. llvm.memcpy.*.*, llvm.memset.*.*, llvm.memmove.*.* (but need an implementation for it and need to stop exporting them).</div><div>3. llvm.trap</div><div>4. llvm.bswap.{i16,i32,i64}</div><div>5. llvm.sqrt.{f32,f64} (errno checking done by library, domain assumed good).</div><div>Initial whitelist for external symbols:</div><div>1. _start</div><div>2. setjmp, longjmp. Will use specially named intrinsics that get translated to native implementations by the translator.</div><div>3. __sync_* for atomics. This is still being experimented with, see Memory Model, Atomics, Fences. The main issue is that not all platforms necessarily provide atomic versions of all of these, but in practice they may all be lowered into single instructions by specific backends.</div><div>Intrinsics disallowed:</div><div>1. llvm.eh.*</div><div>2. llvm.vacopy, llvm.vaend, llvm.vastart</div><div>3. llvm.returnaddress, llvm.frameaddress</div><div>1. Transcendentals: llvm.sin.*, llvm.cos.*, llvm.log*, llvm.exp*, llvm.pow*</div><div>1. Disallow for now, and rely on consistent library implementation.  Explore later with fast-math flags.</div><div>1. llvm.flt.rounds: Disallow for now and expand to “1”. Enable in the future after adding an llvm.flt.set.rounds intrinsic.</div><div>2. llvm.expect: Disallow for now. Have frontend normalize these to branch weight metadata.  Optimize the IR using branch weight metadata, then strip the metadata.</div><div>3. Many others.</div><div>Intrinsics, which seem harmless TBD:</div><div>1. Other gcc __builtin_* intrinsics:</div><div>1. llvm.prefetch</div><div>2. llvm.ctlz.i32, llvm.cttz.i32, llvm.ctpop.i32</div><div><br /></div><div><br /></div><div>Issue: <a href="https://code.google.com/p/nativeclient/issues/detail?id=3378" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=3378</a></div><div><br /></div><div><br /></div><div>Pros:</div><div>1. For a stable ABI it’s important to define exactly what external symbols are allowed to appear in the bitcode. These symbols will have to be provided by future releases of the runtime, or lowered in the translator; therefore, they must be carefully restricted.</div><div>2. This allows us to strictly provide only those intrinsics that are supported in a cross-platform way by the translator.</div><div><br /></div><div><br /></div><div>Restrict bitcode integer and floating-point types</div><div><br /></div><div><br /></div><div>Description: Restrict the bitcode integer types supported by the stable ABI to i1, i8, i16, i32 and i64. Also, restrict the floating-point types to f32, f64.</div><div><br /></div><div><br /></div><div>Issue: <a href="https://code.google.com/p/nativeclient/issues/detail?id=3360" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=3360</a></div><div><br /></div><div><br /></div><div>Pros:</div><div>1. Simplifies the scope of bitcode ABI. Since our current aim is for C and C++ on mainstream 32 or 64-bit CPUs, these sizes seem to be sufficient.</div><div>2. Can have a positive effect on translation time. For the CPUs we target, type legalization that runs during instruction selection would have to reduce types to the ones mentioned above anyway.</div><div>Cons:</div><div>1. Produced code may be potentially slower due to missing an optimization. However, this is questionable since we haven’t yet seen an example of it happening.</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div>Restrict integer arguments and return values to at least i32</div><div><br /></div><div><br /></div><div>Description: LLVM currently allows function return types such as zeroext i8 and signext i8. This complicates the language the PNaCl translator has to handle. We should expand such arguments and return values to always be i32, and handle the sign/zero extensions explicitly in IR code.</div><div><br /></div><div><br /></div><div>Issue: <a href="https://code.google.com/p/nativeclient/issues/detail?id=3342" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=3342</a></div><div><br /></div><div><br /></div><div>Pros:</div><div>1. Simplifies the scope of bitcode ABI.</div><div>2. Removes potential non-portable behaviour, to prevent a pexe from accidentally behaving differently on x86-32 and x86-64 (for example).</div><div><br /></div><div><br /></div><div>________________</div><div><br /></div><div><br /></div><div>Fixed TLS layout for PNaCl</div><div><br /></div><div><br /></div><div>Description: Currently, TLS variables are part of the bitcode ABI. The backend computes the actual layout of TLS variables, which is target dependent. We can compute the TLS layout in advance and encode it in the bitcode. This will leave only the intrinsic that obtains the thread pointer in the ABI.</div><div><br /></div><div><br /></div><div>Issue: <a href="https://code.google.com/p/nativeclient/issues/detail?id=2837" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=2837</a></div><div><br /></div><div><br /></div><div>Pros:</div><div>1. Simplifies the ABI.</div><div>2. Avoids a target dependency and thus simplifies the user threading library (removing the need to support multiple TLS variable layouts).</div><div>3. Removes the need for an ELF linker to allocate TLS variable layout.</div><div>4. Allows the code generator to use shorter instruction sequences for accessing thread-local variables, because thread pointer offsets are known at code gen time.</div><div>Cons:</div><div>1. Limits interoperability with TLS-using native code that’s not built with PNaCl, but this is currently out of scope.</div><div>________________</div><div>Restrict usage of structs, arrays and pointers in the stable bitcode</div><div><br /></div><div><br /></div><div>Description: Struct types add expressiveness to LLVM IR and aid in compiling from C/C++, but play no important role in code generation (after all the mid-level IR passes have run). Since structs can be arbitrarily nested and complex, removing them from the stable bitcode ABI can help simplify it. Similar simplification can be applied to other derived types like arrays and pointers. This also allows to remove the getelementptr instruction from the stable bitcode.</div><div><br /></div><div><br /></div><div>Issues:</div><div>1. <a href="https://code.google.com/p/nativeclient/issues/detail?id=3343" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=3343</a></div><div>2. <a href="https://code.google.com/p/nativeclient/issues/detail?id=3113" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=3113</a> (handling of global initializers)</div><div><br /></div><div><br /></div><div>Concrete proposal details</div><div><br /></div><div><br /></div><div>Struct types and arrays are removed from the stable bitcode ABI. They will instead be represented by pointers. Structs in registers and usages of extractvalue/insertvalue will be expanded to be alloca’d instead, and can then be replaced by pointers. Efficient copies of structs can be replaced by llvm.memcpy calls.</div><div><br /></div><div><br /></div><div>Pointers are replaced by i32 (valid for PNaCl which explicitly sets pointer size to 32 bits in the ABI). Some restricted uses of pointers will be allowed in order to preserve existing semantics of LLVM instructions. For example:</div><div>1. alloca instructions return pointers</div><div>2. load and store instructions require pointers</div><div>3. llvm.memcpy intrinsics require pointers</div><div>The ptrtoint and inttoptr instructions will be employed at conversion points to bridge between addresses contained in i32 values and pointers for the instructions/intrinsics listed above.</div><div><br /></div><div><br /></div><div>Handling getelementptr</div><div><br /></div><div><br /></div><div>getelementptr will be expanded to a sequence of equivalent arithmetic instructions acting on i32 instead of pointers. getelementptr is a complex instruction and it’s worthwhile excluding it from the stable bitcode ABI.</div><div>Note: some measurements indicate that programs compiled with fast isel on x86-64 have performance regressions after GEP removal. This is in accordance to expectations, since fast isel has a special optimization for folding GEPs into addressing modes.</div><div><br /></div><div><br /></div><div>Handling global initializers</div><div><br /></div><div><br /></div><div>A problem with removing the derived types like structs and arrays is handling global initializers, which can’t be easily expanded into code.</div><div><br /></div><div><br /></div><div>For example, this C code:</div><div><br /></div><div><br /></div><div>struct S {</div><div> struct Pair {</div><div>   char c1;</div><div>   char c2;</div><div> } p;</div><div> int *ptr;</div><div>};</div><div>extern int global;</div><div>struct S x[] = { { { 1, 2, }, &amp;global },</div><div>                { { 3, 4, }, &amp;global + 1 } };</div><div><br /></div><div>In LLVM this currently gets represented as:</div><div><br /></div><div>@x = global [2 x %struct.S]</div><div> [%struct.S { %struct.Pair { i8 1, i8 2 }, i32* @global },</div><div>  %struct.S { %struct.Pair { i8 3, i8 4 },</div><div>              i32* getelementptr (i32* @global, i64 1) }], align 16</div><div><br /></div><div><br /></div><div>There are two problems here:</div><div>1. We want to get rid of arbitrarily nested derived types like struct.S</div><div>2. The reference to global within the initializer of x requires a non-trivial constant expression, which we’re also interested in expanding out</div><div><br /></div><div><br /></div><div>The currently leading proposal is to get rid of such initializers in the stable bitcode (wire format) while still using a restricted form of structures and pointers in the bitcode reader and writer in order to keep inter-operating with the existing LLVM backend facilities.</div><div><br /></div><div><br /></div><div>In the bitcode the above initializer will be encoded as two arrays:</div><div>1. An array of bytes</div><div>2. An array of 32-bit “relocations” to globals; a relocation is a pair (offest_into_bytearray, global_var).</div><div><br /></div><div><br /></div><div>For the example above, this is:</div><div><br /></div><div><br /></div><div>Byte array:</div><div> [1, 2, 0, 0,  // c1, c2, padding</div><div>  0, 0, 0, 0,  // addend 0: @global's address will be added</div><div>  3, 4, 0, 0,  // c1, c2, padding</div><div>  4, 0, 0, 0]  // addend 4: @global's address with be added</div><div>Relocations:</div><div> [(4, @global),</div><div>  (12, @global)]</div><div><br /></div><div><br /></div><div>The LLVM IR that will be produced by bitcode reader for this encoded data is:</div><div><br /></div><div><br /></div><div>%flattened_data = type &lt;{ [4 x i8], i32, [4 x i8], i32 }&gt;</div><div>@x_flattened_as_struct = global %flattened_data &lt;{</div><div> [4 x i8] c"\01\02\00\00",</div><div> i32 ptrtoint (i32* @global to i32),</div><div> [4 x i8] c"\03\04\00\00",</div><div> i32 add (i32 ptrtoint (i32* @global to i32), i32 4)</div><div>}&gt;</div><div><br /></div><div><br /></div><div>This re-introduces structs and a restricted usage of constant expressions into LLVM IR, but we are not concerned about IR inside the backend. The goal is to not have these constructs “on the wire”. </div><div><br /></div><div><br /></div><div>For producing such initializers, the PNaCl front-end will include a pass that rewrites global initializers into the “flattened” form shown above, and the bitcode writer will translate it to the byte array + relocations form.</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div>________________</div><div>Define __{init|fini}_array_{start|end} at bitcode creation time</div><div><br /></div><div><br /></div><div>Description: LLVM defines the special global variables llvm.global_ctors and llvm.global_dtors to list global constructors and destructors. On the binary executable level, the special symbols __init_array_start/end and __fini_array_start/end are expected instead by the runtime. We should convert the former to the latter during linking instead of in the translator, so that the special globals variables don’t make it part of the ABI.</div><div><br /></div><div><br /></div><div>Issue: <a href="https://code.google.com/p/nativeclient/issues/detail?id=3018" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=3018</a></div><div><br /></div><div><br /></div><div>Pros:</div><div>1. Smaller scope of stable bitcode ABI.</div><div>2. It is an obstacle to removing the translator's use of the binutils linker (ld).</div><div><br /></div><div><br /></div><div>________________</div><div>C++ exception handling ABI</div><div><br /></div><div><br /></div><div>Not supported in first release. We’ll require code compiled with -fno-exceptions. ABI checker makes sure that landingpad and invoke instructions are not being used in the bitcode.</div><div><br /></div><div><br /></div><div>This issue tracks disallowing invoke/landingpad:</div><div><a href="https://code.google.com/p/nativeclient/issues/detail?id=3377" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=3377</a></div><div><br /></div><div><br /></div><div>Issues for adding exception handling in a later release:</div><div><a href="https://code.google.com/p/nativeclient/issues/detail?id=3118" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=3118</a></div><div><a href="https://code.google.com/p/nativeclient/issues/detail?id=2798" style="color:rgb(17,85,204)" target="_blank">https://code.google.com/p/nativeclient/issues/detail?id=2798</a></div><div><br /></div><div><br /></div><div>Untrusted Fault Handling</div><div><br /></div><div><br /></div><div>Not supported in first release.</div><div><br /></div><div><br /></div><div>________________</div><div>Memory Model, Atomics, Fences</div><div>Syscalls</div><div>One option for atomic and fences is to expose all primitives through NaCl syscalls. The below solution can still generate code that goes through syscalls if needed, but is cleaner in that it doesn’t expose this implementation detail in the pexe. Simply using syscalls also doesn’t specify a memory model for pexes.</div><div><br /></div><div><br /></div><div>C11/C++11</div><div>We can reuse a subset of the C11/C++11 memory model, atomics and fences, as represented in LLVM’s IR. Our goal is for PNaCl to provide a portable memory model and atomic operations for a single program and its threads. This implies that we don’t need to support device memory or cross-program communications through these primitives. In the future, supporting other languages or architectures where either C++’s or LLVM’s representation are insufficient may involve adding more intrinsics or external functions to what we expose.</div><div><br /></div><div><br /></div><div>One point to note is that C++11 also defines limited threads, if we use its memory model and atomics then we should also allow users to use its thread library. There will be some work in supporting the latest runtime libraries to make this happen. For now we expose pthreads, but a future release will support full C11/C++11 runtime.</div><div><br /></div><div><br /></div><div><a href="http://clang.llvm.org/docs/LanguageExtensions.html#c11-atomic-builtins" style="color:rgb(17,85,204)" target="_blank">http://clang.llvm.org/docs/LanguageExtensions.html#c11-atomic-builtins</a></div><div><a href="http://gcc.gnu.org/wiki/Atomic/GCCMM/LIbrary" style="color:rgb(17,85,204)" target="_blank">http://gcc.gnu.org/wiki/Atomic/GCCMM/LIbrary</a></div><div><br /></div><div><br /></div><div>LLVM and GCC also support instructions that aren’t strictly in the standard (nand, min, max, ...) as well as sizes which PNaCl doesn’t support (128-bit integral values). We’ll avoid supporting these for the first release: the representation we choose for C11/C++11 primitives is likely to evolve portably with LLVM releases, but non-standard features may not be as forward-compatible.</div><div><br /></div><div><br /></div><div>Memory Ordering</div><div>C11/C++11 offer 6 different memory orderings, and it’s unclear if LLVM’s implementation is correct for all backends of interest, and if user code will exhibit portable behavior (e.g. it may work on x86 but be incorrect on ARM). One option for a first release would be to change all orderings to sequential consistency in the .pexe, and consider relaxing this requirement in future releases. This would allow code to compile properly, leave older .pexes in a stable state, and allow us to broaden what’s accepted in a later release.</div><div><br /></div><div><br /></div><div>Memory accesses which aren’t explicitly marked as atomic may be reordered, split, fused, or elided. They are emitted by the target machine as-if they were executing on a single thread, unobservable by other threads. This is a source of undefined behavior.</div><div><br /></div><div><br /></div><div>Volatile</div><div>The standard mandates that volatile accesses execute in program order (but are not fences, so other memory operations can reorder around them), are not necessarily atomic, and can’t be elided/fused. Everything else is very target-specific.</div><div><br /></div><div><br /></div><div>The C++ standards committee had a paper about volatile, and decided to leave it unspecified for reasons that PNaCl doesn’t encounter:</div><div>        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html" style="color:rgb(17,85,204)" target="_blank">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2016.html</a></div><div><br /></div><div><br /></div><div>For PNaCl, we can therefore let the optimizer have its way with volatiles on the developer’s machine, but change all volatile accesses to intrinsics/external functions with a specified memory ordering at .pexe creation time. This would isolate a .pexe from future changes in the translator. We could use relaxed ordering (which has stronger semantics than the standard mandates), though the more conservative approach may be to transform all of them to sequentially consistent (even stronger). This eases our support of legacy code, and combined with builtin fences these programs can do meaningful cross-thread communication without changing code.</div><div><br /></div><div><br /></div><div>Pros:</div><div>1. “Porting” to PNaCl means using C11/C++11 or the __sync_* primitives, which is not wasted work. It’s therefore easier to adopt PNaCl, and a lot of existing code will “just work”.</div><div>2. The generated code will be faster than going through NaCl mutex syscalls.</div><div>3. Regular NaCl has access to these atomic instructions, PNaCl doesn’t.</div><div>4. volatile in code “just works” on all target platforms.</div><div>Cons:</div><div>1. 64-bit atomics support may have degraded performance on some MIPS targets (pre-MIPS3?), compared to x86-32, x86-64 and ARMv7. This means that on some platforms where there is no instruction then the implementation must use a lock instead.</div><div>2. The above restriction means that atomics may perform much slower on different platforms. This is really a limitation of platforms, not PNaCl, but it means that timing can be very different from one platform to another, leaking some of the platform-independent abstraction.</div><div>3. Accessing the same memory location without atomics can still have potentially racy behavior, which is also part of the C11/C++11 standard (all such accesses must be through an atomic variable, anything else is undefined).</div><div>4. Atomic accesses are only guaranteed to work on aligned addresses. This is as specified by the C11/C++11 standard, and is often a limitation of the platform too. We could mitigate this with tools like LLVM’s sanitizers.</div><div>5. Ignores multi-program communication as well as devices. So do NaCl and C11/C++11.</div><div>6. The “fast” variants of C++11’s atomics don’t really make sense in the context of PNaCl because their size must be chosen before the target platform is known.</div><div>________________</div><div>Undefined Behavior</div><div><br /></div><div><br /></div><div>C and C++ undefined behavior allows efficient mapping of the source language onto hardware, but leads to different behavior on different platforms.</div><div><br /></div><div><br /></div><div>PNaCl exposes undefined behavior in the following ways:</div><div>   1. The Clang front-end and optimizations that occur on the developer’s machine determine what behavior will occur, and it will be specified deterministically in the pexe. All targets will observe the same behavior. In some cases, recompiling with a newer PNaCl SDK version will either:</div><div>   1. Reliably emit the same behavior in the resulting pexe.</div><div>   2. Change the behavior that gets specified in the pexe.</div><div>   1. The behavior specified in the pexe relies on IR, runtime or CPU architecture vagaries.</div><div>   1. In some cases, the behavior using the same PNaCl translator version on different architectures will produce different behavior.</div><div>   2. Sometimes runtime parameters determine the behavior, e.g. memory allocation determines which out-of-bounds accesses crash versus returning garbage.</div><div>   3. In some cases, different versions of the PNaCl translator (i.e. after a Chrome update) will compile the code differently and cause different behavior.</div><div><br /></div><div><br /></div><div>Specification</div><div>Our goal is that a single pexe should work reliably in the same manner on all architectures, irrespective of runtime parameters and through Chrome updates. We don’t believe that this goal is fully attainable for a first release, we’ve therefore specified as much as we could and will continue improving the situation in subsequent releases.</div><div><br /></div><div><br /></div><div>One interesting solution could be to offer good support for LLVM’s sanitizer tools (including UBSan) at development time, so that developers can test their code against undefined behavior. Shipping code would then still get good performance, and diverging behavior would be rare.</div><div><br /></div><div><br /></div><div>Note that none of these issues are vulnerabilities in PNaCl and Chrome: the NaCl sandboxing still constrains the code through Software Fault Isolation.</div><div><br /></div><div><br /></div><div>Well defined for PNaCl bitcode:</div><div>   1. Dynamic initialization order dependencies → the order is deterministic in the pexe.</div><div>   1. Bool which isn’t 0/1 → the IR instruction sequence is deterministic in the pexe.</div><div>   2. Out-of-range enum → the backing integer type and IR instruction sequence is deterministic in the pexe.</div><div>   3. Reaching end-of-value-returning-function without returning a value → reduces to “ret i32 undef” in IR.</div><div>   4. Aggressive optimizations based on type-based alias analysis → TBAA optimizations are done before stable bitcode is generated and their metadata is stripped from the pexe, behavior is therefore deterministic in the pexe.</div><div>   5. Operator and subexpression evaluation order in the same expression (e.g. function parameter passing, or pre-increment) → the order is defined in the pexe.</div><div>   6. Signed integer overflow → two’s complement integer arithmetic is assumed.</div><div>   7. Atomic access to a non-atomic memory location (not declared as std::atomic) → atomics all lower to the same compatible intrinsics or external functions, the behavior is therefore deterministic in the pexe.</div><div>   8. Integer divide by zero → always raises a fault (through hardware on x86, and through integer divide emulation routine or explicit checks on ARM).</div><div><br /></div><div><br /></div><div>Will not fix:</div><div>   1. Null pointer/reference has behavior determined by the NaCl sandbox:</div><div>   1. Raises a segmentation fault in the bottom 64KiB bytes on all platforms, and on some sandboxes there are further non-writable pages after the initial 64KiB.</div><div>   2. Negative offsets aren’t handled consistently on all platforms: x86-64 and ARM will wrap around to the stack (because they mask the address), whereas x86-32 will fault (because of segmentation).</div><div>   1. Accessing uninitialized/free’d memory (including out-of-bounds array access):</div><div>   1. Might cause a segmentation fault or not, depending on where memory is allocated and how it gets reclaimed.</div><div>   2. Added complexity because of the NaCl sandboxing: some of the load/stores might be forced back into sandbox range, or eliminated entirely if they fall out of the sandbox.</div><div>   1. Executing non-program data (jumping to an address obtained from a non-function pointer is undefined, can only do void(*)() → intptr_t → void(*)().</div><div>   1. Just-In-Time code generation is supported by NaCl, but will not be supported by PNaCl’s first release. It will not be possible to mark code as executable in the first release.</div><div>   2. Offering full JIT capabilities would reduce PNaCl’s ability to change the sandboxing model. It would also require a “jump to JIT code” syscall (to guarantee a calling convention), and means that JITs aren’t portable.</div><div>   3. PNaCl could offer “portable” JIT capabilities where the code hands PNaCl some form of LLVM IR, which PNaCl then JITs.</div><div>   1. Out-of-scope variable usage → will produce unknown data, mostly dependent on stack and memory allocation.</div><div>   2. Data races: any two operations that conflict (target overlapping memory), at least one of which is a store or atomic read-modify-write, and at least one of which is not atomic → this will be very dependent on processor and execution sequence.</div><div><br /></div><div><br /></div><div>Potentially can fix:</div><div>   1. Shift by greater-than-or-equal to left-hand-side’s bit-width or negative.</div><div>   1. Some of the behavior will be specified in the pexe depending on constant propagation and integer type of variables.</div><div>   2. There is still some architecture specific behavior.</div><div>   3. PNaCl could force-mask the right-hand-side to bitwidth-1, which could become a no-op on some architectures while ensuring all architectures behave similarly. Regular optimizations could also be applied, removing redundant masks.</div><div>   1. Using a virtual pointer of the wrong type, or of an unallocated object.</div><div>   1. Will produce wrong results which will depend on what data is treated as a vftable.</div><div>   2. We could add runtime checks for this, and elide them when types are provably correct.</div><div>   1. Some unaligned load/store (also, see atomics above) → could force everything to align 1, performance cost should be measured. The frontend could also be more pessimistic when it sees dubious casts.</div><div>   2. Reaching “unreachable” code.</div><div>   1. LLVM provides an IR instruction called “unreachable” whose effect will be undefined.  We could change this to always trap, as the llvm.trap intrinsic does.</div><div>   1. Zero or negative-sized variable-length array (and alloca) → can insert checks with -fsanitize=vla-bound.</div><div><br /></div><div><br /></div><div>Floating point [Unsorted, will not all be resolved for first launch]:</div><div>   1. Partial IEEE754 implementation:</div><div>   1. Float cast overflow.</div><div>   2. Float divide by zero.</div><div>   3. Different rounding modes.</div><div>   1. Could support switching modes (the 4 modes exposed by C99 FLT_ROUNDS macros).</div><div>   1. Default denormal behavior → we could mandate flush-to-zero, and give an API to enable denormals in a future release.</div><div>   2. Fast-math optimizations:</div><div>   1. We’ll strip fast-math from the pexe for now, but could enable it at a later date, potentially at a perf-function granularity.</div><div>   2. Flush-to-zero → on or off by default? Provide an API?</div><div>   3. Canonical NaN, if any → probably hard to guarantee.</div><div>   4. Ignore NaN to commute operands → only valid with fast-math.</div><div>   5. NaN signaling → fault.</div><div>   6. Passing NaNs to STL functions (the math is defined, but the function implementation isn’t, e.g. std::min/std::max) → will be well-defined in the pexe.</div><div>   7. Fused-multiply-add have higher precision and often execute faster → we could disallow them in the pexe, and only generate them in the backend if fast-math was specified.</div><div>   8. Transcendentals → we could ship with emulation routines whose behavior is well-known, and use the hardware if fast-math is provided.</div><div><br /></div><div></div></div></div></div><div style="margin:15px 0px;clear:both;font-size:12.727272033691406px;color:rgb(34,34,34);font-family:arial,sans-serif"></div></div></td></tr></tbody></table>
</div> 
</div> 
<div id="sites-canvas-bottom-panel">
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_page-subpages"> </div>
<div id="sites-attachments-container">
<div xmlns="http://www.w3.org/1999/xhtml" id="sites-attachments">
<div class="sites-attachments-row"><div class="sites-attachments-icon" style="left:0px;"><span aria-label="Attachments" title="Attachments"><div class="sites-translucent sites-symbol" aria-hidden="true">Č</div></span></div><div id="sites-attachments-update-div" class="sites-attachments-inner-div" style="display:none;"><span class="sites-attachments-update-icon"><img src="http://www.gstatic.com/sites/p/56e332/system/app/images/spinner.gif" /></span><div class="sites-attachments-update-text">Updating...</div></div></div><div class="sites-attachments-separator"></div>
<div id="attachment-wuid:gx:49f0f5daac9cc815"><div class="sites-attachments-row"><div class="sites-attachments-icon sites-attachments-icon-accessible" style="left:5px"><span class="sites-symbol sites-color-adobe-pdf" aria-label="Adobe PDF" title="Adobe PDF">Ċ</span></div><div class="sites-attachments-inner-div"><div class="sites-attachments-name"><a href="http://docs.google.com/viewer?a=v&amp;pid=sites&amp;srcid=Y2hyb21pdW0ub3JnfGRldnxneDo0OWYwZjVkYWFjOWNjODE1">StabilityofthePNaClbitcodeABI.pdf</a> <div class="sites-translucent">(433k)</div></div><div class="sites-attachments-author">Eli Bendersky, <div class="sites-translucent">Jun 18, 2013, 8:20 AM</div></div></div><div class="sites-attachments-version sites-attachments-version-accessible"><a href="/system/app/pages/admin/revisions?wuid=wuid:gx:49f0f5daac9cc815">v.1</a></div><div id="attachment-download-wuid:gx:49f0f5daac9cc815" class="sites-attachments-icon sites-attachments-icon-accessible" style="right:0px"><a href="/nativeclient/pnacl/stability-of-the-pnacl-bitcode-abi/StabilityofthePNaClbitcodeABI.pdf?attredirects=0&amp;d=1" aria-label="Download StabilityofthePNaClbitcodeABI.pdf" title="Download" role="button"><span class="sites-symbol" aria-hidden="true">ď</span></a></div></div><div class="sites-attachments-separator"></div></div>
<div style="height: 10px"></div>
</div>
</div>
<a xmlns="http://www.w3.org/1999/xhtml" name="page-comments"></a>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_page-comments"><div class="sites-comment-docos-wrapper"><div class="sites-comment-docos"><div class="sites-comment-docos-background"></div><div class="sites-comment-docos-header"><div class="sites-comment-docos-header-title">Comments</div></div><div id="sites-comment-docos-pane" class="sites-comment-docos-pane"></div></div></div></div>
</div>
</div> 
</td> 
</tr>
</table> 
</div> 
</div> 
<div id="sites-chrome-footer-wrapper">
<div id="sites-chrome-footer-wrapper-inside">
<div id="sites-chrome-footer">
</div>
</div>
</div>
</div> 
</div> 
<div id="sites-chrome-adminfooter-container">
<div xmlns="http://www.w3.org/1999/xhtml" class="sites-adminfooter" role="navigation"><p><a class="sites-system-link" href="https://www.google.com/a/UniversalLogin?service=jotspot&amp;continue=http://sites.google.com/a/chromium.org/dev/nativeclient/pnacl/stability-of-the-pnacl-bitcode-abi">Sign in</a><span aria-hidden="true">|</span><a class="sites-system-link" href="/system/app/pages/recentChanges">Recent Site Activity</a><span aria-hidden="true">|</span><a class="sites-system-link" href="/system/app/pages/reportAbuse" target="_blank">Report Abuse</a><span aria-hidden="true">|</span><a class="sites-system-link" href="javascript:;" onclick="window.open(webspace.printUrl)">Print Page</a><span aria-hidden="true">|</span><span class="sites-system-link">Powered By</span> <b class="powered-by"><a href="http://sites.google.com">Google Sites</a></b></p></div>
</div>
</div> 
</div> 
<div id="sites-chrome-onebar-footer">
</div>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    window.jstiming.load.tick('sjl');
  </script>
<script xmlns="http://www.w3.org/1999/xhtml" src="http://www.gstatic.com/sites/p/56e332/system/js/jot_min_view__en.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    window.jstiming.load.tick('jl');
  </script>
<script xmlns="http://www.w3.org/1999/xhtml">
      
          sites.core.Analytics.createTracker();
          sites.core.Analytics.trackPageview();
        
    </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
                    sites.Searchbox.initialize(
                        'sites-searchbox-search-button',
                        {"object":[]}['object'],
                        'search-site',
                        {"label":"Configure search options...","url":"/system/app/pages/admin/settings"});
                  </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
      gsites.HoverPopupMenu.createSiteDropdownMenus('sites-header-nav-dropdown', false);
    </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" defer="true">
            JOT_setupNav("7648876402527094", "Navigation", false);
            JOT_addListener('titleChange', 'JOT_NAVIGATION_titleChange', 'COMP_7648876402527094');
          </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" defer="true">
            JOT_setupNav("14720868319272995", "Quick links", false);
            JOT_addListener('titleChange', 'JOT_NAVIGATION_titleChange', 'COMP_14720868319272995');
          </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" defer="true">
            JOT_setupNav("19690813310444355", "Other sites", false);
            JOT_addListener('titleChange', 'JOT_NAVIGATION_titleChange', 'COMP_19690813310444355');
          </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
              new sites.CommentPane('//docs.google.com/comments/d/AAHRpnXvrAwjAfmld0ObrebBiGRq90G5H1d6nnIwPYoXL5YHidpwmQnynZMIBhi3KkB_j7-Y2eAKaaEwoNF3_se3WO61o3wiZB7kv3eLiO__cK22SDewYZLxfcrD0FFShtyn2frZSZapq/api/js?anon=true',
                  false, false);
            </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
  setTimeout(function() {
    var fingerprint = gsites.date.TimeZone.getFingerprint([]);
    gsites.Xhr.send('http://www.chromium.org/_/tz', null, null, 'GET', null, null, { afjstz: fingerprint });
  }, 500);
</script>
<script xmlns="http://www.w3.org/1999/xhtml">
                    window.onload = function() {
                      if (false) {
                        JOT_setMobilePreview();
                      }
                      var loadTimer = window.jstiming.load;
                      loadTimer.tick("ol");
                      loadTimer["name"] = "load," + webspace.page.type + ",user_page";
                      window.jstiming.report(loadTimer, {}, 'http://csi.gstatic.com/csi');
                    }
                  </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
        JOT_insertAnalyticsCode(false,
            false);
      </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    var maestroRunner = new gsites.pages.view.SitesMaestroRunner(
        webspace, "en");
    maestroRunner.initListeners();
    maestroRunner.installEditRender();
  </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" defer="true">
  //<![CDATA[
    // Decorate any fastUI buttons on the page with a class of 'goog-button'.
    if (webspace.user.hasWriteAccess) {
      JOT_decorateButtons();
    }

    // Fires delayed events.
    (function() {
      JOT_fullyLoaded = true;
      var delayedEvents = JOT_delayedEvents;
      for (var x = 0; x < delayedEvents.length; x++) {
        var event = delayedEvents[x];
        JOT_postEvent(event.eventName, event.eventSrc, event.payload);
      }
      JOT_delayedEvents = null;
      JOT_postEvent('pageLoaded');
    })();
  //]]>
</script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    JOT_postEvent('decorateGvizCharts');
  </script>
<script type="text/javascript">
          JOT_setupPostRenderingManager();
        </script>
<script type="text/javascript">
          JOT_postEvent('renderPlus', null, 'sites-chrome-main');
        </script>
<div id="server-timer-div" style="display:none"> </div>
<script type="text/javascript">
          window.jstiming.load.tick('render');
          JOT_postEvent('usercontentrendered', this);
        </script>
</body>
</html>
