<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="http://schema.org/WebPage">
<head>
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<script type="text/javascript">/* Copyright 2008 Google. */ (function() { var e="wtsrt_",g="tbsd_",h="tbnd_",k="start",l="_wtsrt",m="_tbnd",n="CSI/";(function(){function f(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp(n+a)}catch(d){}};this.tick(k,null,a)}var a;window.performance&&(a=window.performance.timing);var p=a?new f(a.responseStart):new f;window.jstiming={Timer:f,load:p};if(a){var c=a.navigationStart,d=a.responseStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick(l,void 0,c),b.tick(e,l,d),b.tick(g,e))}try{a=null,
window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick(m,void 0,window.chrome.csi().startE),b.tick(h,m,c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick(m,void 0,window.external.startE),b.tick(h,m,c))),a&&(window.jstiming.pt=a)}catch(q){}})(); })()
</script>
<link rel="shortcut icon" href="../../_/rsrc/1354323194313/favicon.ico" type="image/x-icon" />
<link rel="apple-touch-icon" href="https://ssl.gstatic.com/sites/p/56e332/system/app/images/apple-touch-icon.png" type="image/png" />
<script type="text/javascript">/* Copyright 2008 Google. */ (function() { var d="",g="__duration__",h="function";function k(c){return document.getElementById(c)}window.byId=k;function l(c){return c.replace(/^\s+|\s+$/g,d)}window.trim=l;var m=[],n=0;window.JOT_addListener=function(c,a,b){var e=new String(n++);c={eventName:c,handler:a,compId:b,key:e};m.push(c);return e};window.JOT_removeListenerByKey=function(c){for(var a=0;a<m.length;a++)if(m[a].key==c){m.splice(a,1);break}};
window.JOT_removeAllListenersForName=function(c){for(var a=0;a<m.length;a++)m[a].eventName==c&&m.splice(a,1)};window.JOT_postEvent=function(c,a,b){var e={eventName:c,eventSrc:a||{},payload:b||{}};if(window.JOT_fullyLoaded)for(a=m.length,b=0;b<a&&b<m.length;b++){var f=m[b];f&&f.eventName==c&&(e.listenerCompId=f.compId||d,(f=typeof f.handler==h?f.handler:window[f.handler])&&f(e))}else window.JOT_delayedEvents.push({eventName:c,eventSrc:a,payload:b})};window.JOT_delayedEvents=[];
window.JOT_fullyLoaded=!1;window.JOT_formatRelativeToNow=function(c,a){var b=((new Date).getTime()-c)/6E4;if(1440<=b||0>b)return null;var e=0;60<=b&&(b/=60,e=2);2<=b&&e++;return a?window.JOT_siteRelTimeStrs[e].replace(g,Math.floor(b)):window.JOT_userRelTimeStrs[e].replace(g,Math.floor(b))}; })()
</script>
<script>

  

  var breadcrumbs = [{"path":"/chromium-os","deleted":false,"title":"Chromium OS","dir":"ltr"},{"path":"/chromium-os/chromiumos-design-docs","deleted":false,"title":"Design Documents","dir":"ltr"},{"path":"/chromium-os/chromiumos-design-docs/firmware-boot-and-recovery","deleted":false,"title":"Firmware Boot and Recovery","dir":"ltr"}];
  var JOT_clearDotPath = 'https://ssl.gstatic.com/sites/p/56e332/system/app/images/cleardot.gif';

  
  var JOT_userRelTimeStrs = ["a minute ago","__duration__ minutes ago","an hour ago","__duration__ hours ago"];

  
  

  

  var webspace = {"enableAnalytics":true,"pageSharingId":"jotspot_page","enableUniversalAnalytics":false,"sharingPolicy":"OPENED_WITH_INDICATOR","siteTitle":"The Chromium Projects","isStartPageEnabled":true,"adsensePublisherId":null,"features":{"languageSelectDefaultTextSetToDefault":true,"validateClientGvizDataSourceUrls":true,"moreMobileStyleImprovements":true,"newInsertMenuIcons":true,"accessibleSortingButtons":true,"domainAnalyticsInGAOnly":true,"noCaptcha":true,"fileCabinetScreenReaderFix":true,"updatedTosAndPrivacyLinks":null,"pageDrafts":false,"mobileOrientationFix":true,"plusBadge":false,"pdfEmbedSupport":false,"jsClickFix":true},"isPublic":true,"isConsumer":false,"serverFlags":{"cajaBaseUrl":"//www.gstatic.com/caja","cajaDebugMode":false},"onepickBaseUrl":"https://docs.google.com","domainAnalyticsAccountId":"","plusPageId":"","signInUrl":"https://www.google.com/a/SelectSession?continue\u003dhttps://sites.google.com/a/chromium.org/dev/chromium-os/chromiumos-design-docs/firmware-boot-and-recovery\u0026service\u003djotspot","analyticsAccountId":"UA-5484340-1","scottyUrl":"/_/upload","homePath":"/","siteNoticeUrlEnabled":null,"plusPageUrl":"","adsensePromoClickedOrSiteIneligible":true,"csiReportUri":"https://gg.google.com/csi","sharingId":"jotspot","termsUrl":"//www.google.com/intl/en/policies/terms/","gvizVersion":1,"editorResources":{"sitelayout":["https://ssl.gstatic.com/sites/p/56e332/system/app/css/sitelayouteditor.css"],"text":["https://ssl.gstatic.com/sites/p/56e332/system/js/codemirror.js","https://ssl.gstatic.com/sites/p/56e332/system/app/css/codemirror_css.css","https://ssl.gstatic.com/sites/p/56e332/system/js/trog_edit__en.js","https://ssl.gstatic.com/sites/p/56e332/system/app/css/trogedit.css","/_/rsrc/1441580320000/system/app/css/editor.css","https://ssl.gstatic.com/sites/p/56e332/system/app/css/codeeditor.css","/_/rsrc/1441580320000/system/app/css/camelot/editor-jfk-wlb.css"]},"sharingUrlPrefix":"/_/sharing","isAdsenseEnabled":true,"domain":"chromium.org","baseUri":"","name":"dev","siteTemplateId":false,"siteNoticeRevision":null,"siteNoticeUrlAddress":null,"siteNoticeMessage":null,"page":{"isRtlLocale":false,"canDeleteWebspace":null,"isPageDraft":null,"parentPath":"/chromium-os/chromiumos-design-docs","parentWuid":"wuid:gx:2eb69dd73ece341e","siteLocale":"en","timeZone":"America/Los_Angeles","type":"text","title":"Firmware Boot and Recovery","locale":"en","wuid":"wuid:gx:418ed39a3963e742","revision":11,"path":"/chromium-os/chromiumos-design-docs/firmware-boot-and-recovery","isSiteRtlLocale":false,"pageInheritsPermissions":null,"name":"firmware-boot-and-recovery","canChangePath":true,"state":"","properties":{},"bidiEnabled":false,"currentTemplate":{"path":"/system/app/pagetemplates/text","title":"Web Page"}},"canPublishScriptToAnyone":true,"user":{"keyboardShortcuts":true,"sessionIndex":"","guest_":true,"displayNameOrEmail":"guest","userName":"guest","uid":"","renderMobile":false,"domain":"","namespace":"","hasWriteAccess":false,"namespaceUser":false,"primaryEmail":"guest","hasAdminAccess":false},"gadgets":{"baseUri":"/system/app/pages/gadgets"}};
  webspace.page.breadcrumbs = breadcrumbs;

  
  var JOT_siteRelTimeStrs = ["a minute ago","__duration__ minutes ago","an hour ago","__duration__ hours ago"];

</script>
<script type="text/javascript">
                window.jstiming.load.tick('scl');
              </script>
<meta name="title" content="Firmware Boot and Recovery - The Chromium Projects" />
<meta itemprop="name" content="Firmware Boot and Recovery - The Chromium Projects" />
<meta property="og:title" content="Firmware Boot and Recovery - The Chromium Projects" />
<meta name="description" content="Home of the Chromium Open Source Project" />
<meta itemprop="description" content="Home of the Chromium Open Source Project" />
<meta id="meta-tag-description" property="og:description" content="Home of the Chromium Open Source Project" />
<style type="text/css">
</style>
<link rel="stylesheet" type="text/css" href="https://ssl.gstatic.com/sites/p/56e332/system/app/themes/beigeandblue/standard-css-beigeandblue-ltr-ltr.css" />
<link rel="stylesheet" type="text/css" href="../../_/rsrc/1441580320000/system/app/css/overlay.css%3Fcb=beigeandblueundefineda100%2525%2525150goog-ws-leftthemedefaultstandard.css" />
<link rel="stylesheet" type="text/css" href="../../_/rsrc/1441580320000/system/app/css/camelot/allthemes-view.css" />
<!--[if IE]>
          <link rel="stylesheet" type="text/css" href="/system/app/css/camelot/allthemes%2die.css" />
        <![endif]-->
<title>Firmware Boot and Recovery - The Chromium Projects</title>
<meta itemprop="image" content="https://www.chromium.org/_/rsrc/1258650191714/chromium-os/chromiumos-design-docs/firmware-boot-and-recovery/eeprom-mappng" />
<meta property="og:image" content="https://www.chromium.org/_/rsrc/1258650191714/chromium-os/chromiumos-design-docs/firmware-boot-and-recovery/eeprom-mappng" />
<script type="text/javascript">
                window.jstiming.load.tick('cl');
              </script>
</head>
<body xmlns="http://www.google.com/ns/jotspot" id="body" class=" en            ">
<div id="sites-page-toolbar" class="sites-header-divider">
<div xmlns="http://www.w3.org/1999/xhtml" id="sites-status" class="sites-status" style="display:none;"><div id="sites-notice" class="sites-notice" role="status" aria-live="assertive"> </div></div>
</div>
<div id="sites-chrome-everything-scrollbar">
<div id="sites-chrome-everything" class="">
<div id="sites-chrome-page-wrapper" style="direction: ltr">
<div id="sites-chrome-page-wrapper-inside">
<div xmlns="http://www.w3.org/1999/xhtml" id="sites-chrome-header-wrapper" style="height:auto;">
<table id="sites-chrome-header" class="sites-layout-hbox" cellspacing="0" style="height:auto;">
<tr class="sites-header-primary-row" id="sites-chrome-userheader">
<td id="sites-header-title" class="" role="banner"><div class="sites-header-cell-buffer-wrapper"><a href="../../index.html" id="sites-chrome-userheader-logo"><img id="logo-img-id" src="../../_/rsrc/1438879449147/config/customLogo.gif%3Frevision=3" alt="The Chromium Projects" class="sites-logo  " /></a><h2><a href="../../index.html" dir="ltr" id="sites-chrome-userheader-title">The Chromium Projects</a></h2></div></td><td class="sites-layout-searchbox  "><div class="sites-header-cell-buffer-wrapper"><form id="sites-searchbox-form" action="https://www.chromium.org/system/app/pages/search" role="search"><input type="hidden" id="sites-searchbox-scope" name="scope" value="search-site" /><input type="text" id="jot-ui-searchInput" name="q" size="20" value="" aria-label="Search this site" /><div id="sites-searchbox-button-set" class="goog-inline-block"><div role="button" id="sites-searchbox-search-button" class="goog-inline-block jfk-button jfk-button-standard" tabindex="0">Search this site</div></div></form></div></td>
</tr>
<tr class="sites-header-secondary-row" id="sites-chrome-horizontal-nav">
<td colspan="2" id="sites-chrome-header-horizontal-nav-container" role="navigation">
</td>
</tr>
</table>
</div>
<div id="sites-chrome-main-wrapper">
<div id="sites-chrome-main-wrapper-inside">
<table id="sites-chrome-main" class="sites-layout-hbox" cellspacing="0" cellpadding="{scmCellpadding}" border="0">
<tr>
<td id="sites-chrome-sidebar-left" class="sites-layout-sidebar-left initial" style="width:150px">
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_7648876402527094" class="sites-embed" role="navigation"><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotId="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="../../chromium-projects.html" jotId="wuid:gx:10ae433dadbbab13" class="sites-navigation-link">Home</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="../../Home.1.html" jotId="wuid:gx:43582b9d2029d3af" class="sites-navigation-link">Chromium</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="../../chromium-os.1.html" jotId="wuid:gx:83df2ab1f8880ba" class="sites-navigation-link">Chromium OS</a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_14720868319272995" class="sites-embed" role="navigation"><h4 class="sites-embed-title">Quick links</h4><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotId="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="../../for-testers/bug-reporting-guidelines.html" class="sites-navigation-link">Report bugs</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="../../developers/discussion-groups.html" class="sites-navigation-link">Discuss</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="../../system/app/pages/sitemap/hierarchy.html" jotId="wuid:gx:571d8fbd499df20e" class="sites-navigation-link">Sitemap</a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_19690813310444355" class="sites-embed" role="navigation"><h4 class="sites-embed-title">Other sites</h4><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotId="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="http://blog.chromium.org/" class="sites-navigation-link">Chromium Blog</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="http://code.google.com/chrome/extensions/" class="sites-navigation-link">Google Chrome Extensions</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="https://developers.google.com/chrome/chrome-frame/" class="sites-navigation-link">Google Chrome Frame</a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_19695218559354544" class="sites-embed" role="complementary"><h4 class="sites-embed-title"></h4><div class="sites-embed-content sites-embed-content-sidebar-textbox"><div dir="ltr"><span style="font-size:x-small">Except as otherwise </span><a href="http://developers.google.com/site-policies.html#restrictions"><span style="font-size:x-small">noted</span></a><span style="font-size:x-small">, the content of this page is licensed under a </span><a href="http://creativecommons.org/licenses/by/2.5/"><span style="font-size:x-small">Creative Commons Attribution 2.5 license</span></a><span style="font-size:x-small">, and examples are licensed under the </span><a href="http://src.chromium.org/viewvc/chrome/trunk/src/LICENSE" target="_blank"><span style="font-size:x-small">BSD License</span></a><span style="font-size:x-small">.<br /></span></div></div></div>
</td>
<td id="sites-canvas-wrapper">
<div id="sites-canvas" role="main">
<div id="goog-ws-editor-toolbar-container"> </div>
<div xmlns="http://www.w3.org/1999/xhtml" id="title-crumbs" style="">
<A href="../../chromium-os.1.html" dir="ltr">Chromium OS</A>‎ &gt; ‎<A href="../chromiumos-design-docs.1.html" dir="ltr">Design Documents</A>‎ &gt; ‎
  </div>
<h3 xmlns="http://www.w3.org/1999/xhtml" id="sites-page-title-header" style="" align="left">
<span id="sites-page-title" dir="ltr" tabindex="-1" style="outline: none">Firmware Boot and Recovery</span>
</h3>
<div id="sites-canvas-main" class="sites-canvas-main">
<div id="sites-canvas-main-content">
<table xmlns="http://www.w3.org/1999/xhtml" cellspacing="0" class="sites-layout-name-one-column sites-layout-hbox"><tbody><tr><td class="sites-layout-tile sites-tile-name-content-1"><div dir="ltr"><div>
<div class="sites-embed-align-right-wrapping-on"><div class="sites-embed-border-off sites-embed" style="width:250px;"><div class="sites-embed-content sites-embed-type-toc"><div class="goog-toc sites-embed-toc-maxdepth-6"><p>Contents</p><ol class="goog-toc"><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#TOC-Abstract"><strong>1 </strong>Abstract</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Potential_Problems_06602847948"><strong>2 </strong>Potential problems</a><ol class="goog-toc"><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Firmware_6345705660060048_1740"><strong>2.1 </strong>Firmware</a></li></ol></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Design_Decisions_8644751217216"><strong>3 </strong>Design decisions</a><ol class="goog-toc"><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Boot_needs_to_start_securely_5"><strong>3.1 </strong>Boot needs to start securely</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Writable_firmware_should_have__7966560075305942"><strong>3.2 </strong>Writable firmware should have a backup</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Recovery_firmware_should_be_re_024671708017260596"><strong>3.3 </strong>Recovery firmware must be read-only</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Recovery_firmware_does_not_nee_43765456105130307"><strong>3.4 </strong>Recovery firmware does not need to access the network</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Recovery_firmware_should_tell_"><strong>3.5 </strong>Recovery firmware should tell the user how to recover</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Users_should_be_able_to_manual"><strong>3.6 </strong>Users must be able to manually trigger recovery mode</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Support_developers_l33t_users_"><strong>3.7 </strong>Support developers / l33t users installing their own software</a></li></ol></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#EEPROM_Map_19483716413378716_0_8527987941869014"><strong>4 </strong>EEPROM map</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#TOC-Firmware-block-descriptions"><strong>5 </strong>Firmware block descriptions</a><ol class="goog-toc"><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Boot_Stub_2175902035087347_738"><strong>5.1 </strong>Boot stub</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Firmware_A_B_Setup_41671303566"><strong>5.2 </strong>Firmware (A/B) setup</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Firmware_A_B_Bootstrap_6854730_9843585162384771"><strong>5.3 </strong>Firmware (A/B) boot loader</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Boot_Log_909660461358726_02223_241900222824606"><strong>5.4 </strong>Boot log</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Recovery_Firmware_325963526964_9310128691004004"><strong>5.5 </strong>Recovery firmware</a></li></ol></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Recovery_Image_999069100245833_9862531434570179"><strong>6 </strong>Recovery image</a><ol class="goog-toc"><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Recovery_via_Chrome_OS_2183209_6000941713093587"><strong>6.1 </strong>Recovery via Chromium OS</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Making_Recovery_Images_Read_On"><strong>6.2 </strong>Making recovery images read-only</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Using_Recovery_Mode_to_load_De"><strong>6.3 </strong>Using recovery mode to load developer mode firmware/software</a></li></ol></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Boot_Flowchart_033826657570898"><strong>7 </strong>Boot flowchart</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#TOC-Other-notes"><strong>8 </strong>Other notes</a><ol class="goog-toc"><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Verification_of_the_Rest_of_ro"><strong>8.1 </strong>Verification of the rest of the rootfs</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#When_to_Verify_the_Boot_Proces"><strong>8.2 </strong>When to verify the boot process</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Handling_Returned_Netbooks_578"><strong>8.3 </strong>Handling returned systems</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Testing_17694905913316072_043226863012933325"><strong>8.4 </strong>Testing</a></li></ol></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Open_Issues_6727640628814697_9"><strong>9 </strong>Open issues</a><ol class="goog-toc"><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#What_Else_Do_We_Need_To_Verify"><strong>9.1 </strong>What else do we need to verify?</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Can_we_log_firmware_crashes_54_8565273169739532"><strong>9.2 </strong>Can we log firmware crashes?</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Chain_of_verification_on_ARM_2_45279574090983055"><strong>9.3 </strong>Chain of verification on ARM?</a></li><li class="goog-toc"><a href="firmware-boot-and-recovery.1.html#Support_for_Trusted_Platform_M_472807140635382"><strong>9.4 </strong>Support for Trusted Platform Module (TPM)?</a></li></ol></li></ol></div></div></div></div>
<h2><a name="TOC-Abstract"></a>Abstract</h2>
<div style="margin-top:0px;margin-bottom:0px">
<ul style="margin-top:0px;margin-bottom:0px"><li style="margin-top:0px;margin-bottom:0px">The layout and structure of firmware for Chromium OS is designed for security (see <a href="verified-boot.1.html">Verified Boot</a> documentation), recovery and development.</li>
<li style="margin-top:0px;margin-bottom:0px">All firmware will contain a recovery code path, which will restore the machine to its original Chromium OS state. This recovery code path will be initiated either when any chain in the boot path is not verified or when a user manually triggers recovery mode, likely via an explicit recovery button on the device.</li>
<li style="margin-top:0px;margin-bottom:0px">Chromium OS wants to support developers as well. Developers are provided with a means of running alternate software. In the alternate boot paths, the user is notified that they are not running a boot path provided as part of Chromium OS.</li>
<li style="margin-top:0px;margin-bottom:0px">The boot and recovery procedures outlined will be implemented and required for all Chromium OS platforms regardless of architecture (ARM/Intel/etc...).</li></ul></div></div>
<p>
</p>
<p>
  This document describes the firmware boot process, including detection and recovery of corrupted or hacked firmware/software.
</p>
<h2><a name="Potential_Problems_06602847948"></a>
   Potential problems
</h2>
<div>
  The firmware boot process must be able to detect the following problems and, if possible, repair them.
</div>
<h3><a name="Firmware_6345705660060048_1740"></a>
   Firmware
</h3>
<div>
<ol>
<li>Incomplete update: An update of the firmware is interrupted. This leaves the portion of the firmware which was being updated in an unknown or corrupt state. For example, if the update is interrupted after a firmware block is erased but before it is reprogrammed, that block is empty.
    </li>
<li>Attack: An attacker compromises the software and is able to reprogram the firmware. For example, an exploit of an unpatched kernel vulnerability. In this case, both the main and backup firmware may be compromised.
    </li>
<li>Corruption: The EEPROM holding the firmware becomes corrupted in the sectors containing writable/updatable firmware.
    </li>
</ol>
</div>
<div>
<b>Software</b>
</div>
<div>
<ol>
<li>Incomplete update: An update of the software on the drive is interrupted. This leaves the rootfs partition in an unknown state.
    </li>
<li>Attack: An attacker compromises the software and is able to rewrite the data on the drive (rootfs or partition table).
    </li>
<li>Malicious user: A malicious user installs developer mode onto the device, leaving behind a trojan, then returns the device.
    </li>
<li>Corruption: The drive becomes corrupted in the partition table or rootfs partition.
    </li>
<li>Crash: Device crashes on boot due to bad software. For example, the device is updated with the wrong image. This prevents the normal autoupdate process from running.</li>
</ol>
<div>
<b>Out of scope</b>
</div>
</div>
<div>
<br />
</div>
<div>
  The following problems are outside the scope of this document in its current form:
</div>
<div>
<ol>
<li>
      An attacker with physical access to the device opens the device and alters its innards. This includes:
    </li>
<ul>
<li>
        Jumpering the EEPROM to gain write access to the read-only portion.
      </li>
<li>
        Replacing the EEPROM.
      </li>
<li>
        Otherwise altering the circuit board (adding piggyback chips, etc).
      </li>
</ul>
<li>
      Exploits involving the normally-writable data partition. 
    </li>
<ul>
<li>
        Changing bookmarks to point to sites which download HTML5 malware, etc.
      </li>
<li>
        Malformed bookmarks file or image which causes a buffer overrun when parsed
      </li>
<li>
        Changing the preferred wireless network to a malicious one which logs/alters packets
      </li></ul>
<li>Exploits involving other processors (embedded controller, modem processor, etc.)</li>
<ul>
</ul>
<ul>
</ul>
</ol>
<h2><a name="Design_Decisions_8644751217216"></a>
     Design decisions
  </h2>
<h3><a name="Boot_needs_to_start_securely_5"></a>
     Boot needs to start securely
  </h3>
</div>
<div>In order to attempt a secure boot, the initial boot stub needs to perform a minimum level of initialization to verify the next piece of boot code before handing off to that code.
</div>
<div><br />
</div>
<div>
  To prevent accidental or intentional corruption of the known-good boot stub, this code must be in a portion of memory which is not field-writable. Many EEPROM devices have an external pin (<u>WP</u>) which can be pulled low to write protect the upper portion of the EEPROM. This has a number of benefits:
</div>
<ul>
<li>
    Devices are writable at time of manufacture (as opposed to true ROMs, which are fixed at time of ROM manufacture).
  </li>
<li>
    Devices can be made writable for firmware development by simple hardware modification.
  </li>
<li>
    Both readable and read-only ROM are provided by a single device. Simpler board design, fewer parts, lower cost.
  </li>
<li>
    Any attacker who can open the case and modify the hardware to write to the protected upper portion of ROM could also simply replace a true ROM with a reprogrammed part, so this isn't significantly less secure than a true ROM.
  </li>
</ul>
<div>
  On ARM platforms, the initial boot ROM may be in the same package as the processor. This is even more secure compared to a separate EEPROM.</div>
<h3><a name="Writable_firmware_should_have__7966560075305942"></a>
   Writable firmware should have a backup
</h3>
<div>
  To protect against a failed firmware update, the writable portion of the firmware (responsible for doing the remainder of chipset and storage setup and then bootstrapping the kernel off the storage device) should exist in two copies. In the event the first copy is corrupt, the device can boot normally off the second copy. This is similar to the design for the <a href="filesystem-autoupdate.html">file system</a>, which has two copies of the root partition.</div>
<h3><a name="Recovery_firmware_should_be_re_024671708017260596"></a>
   Recovery firmware must be read-only
</h3>
<div>
  Recovery firmware must be able to take over the boot process if the boot stub determines that the normal writable firmware is corrupt, or if the user manually boots the device into recovery mode.</div>
<div>
<br />
</div>
<div>
  To prevent the recovery firmware from being corrupted by a firmware update or a software-based attack, it must be in the same read-only portion of the EEPROM as the boot stub.
</div>
<h3><a name="Recovery_firmware_does_not_nee_43765456105130307"></a>
   Recovery firmware does not need to access the network
</h3>
<div>
  The recovery process should not require firmware-level network access by the device being recovered.  The recovery procedure can involve a second computer, which is used to create recovery media (for example, a USB drive or SD card). It is assumed that second computer has network access.</div>
<div>
<br />
</div>
<div>
  This simplifies the recovery process, since the recovery firmware only needs to bring up enough of the system to bootstrap a Linux image from local storage. That image can then take care of reflashing the EEPROM and reimaging. 
</div>
<div>
<br />
</div>
<div>
  It is not necessary to implement a full network stack with WiFi configuration in the recovery firmware to support PXE boot. PXE boot introduces a number of complications:</div>
<div>
<ul><li>Need to initialize more hardware to bring up wireless, keyboard, etc.</li>
<li>Need to implement a full network stack.</li>
<li>Makes recovery an interactive process, including the user entering their SSID and WPA key, which the user may not know.</li>
<li>Unlikely to work for public WiFi access points; these often redirect http access to a login screen, navigation of which which would necessitate a full browser in the recovery firmware.</li>
<li>Unlikely to work for cellular networks (3G/4G/etc...), if that requires more complicated drivers or configuration.</li></ul>
<div>All of these issues would need to be resolved, and the resulting firmware must be correct at the time the device ships, because recovery mode firmware can't be updated in the field. It is unacceptable to ship a mostly-working PXE solution, assuming that the user can fall back on a second computer in the event PXE recovery fails. The only time the user would discover PXE recovery didn't work is when the user is relying on it to repair their computer.</div>
<div><br />
</div>
</div>
<div>More information on wireless network boot is here: <a href="http://etherboot.org/wiki/wirelessboot">http://etherboot.org/wiki/wirelessboot</a>.<br />
<div>
<h3><a name="Recovery_firmware_should_tell_"></a>
    Recovery firmware should tell the user how to recover
  </h3>
<div>
    If the recovery firmware finds a USB drive/SD card with a good recovery image on it, it should boot it and use that to recover. The software in that recovery image will have its own user interface to guide the user through recovery.</div>
<div>
<br />
</div>
<div>
    If the recovery firmware does not find a good recovery image, it needs to tell the user how to use a second computer to build that recovery image.
  </div>
<div>
<div>
<br />
</div>
<div>The preferred way to do this is to initialize the screen and show recovery instructions to the user, including a URL to go to in that second computer's web browser. Note that recovery instructions need to be displayed in the correct language for the user.</div>
</div>
</div>
</div>
<div>
<p>It is desirable for the recovery instructions and/or recovery URL to include a code for the device model. This allows the destination website to:</p>
<div>
<div>
<div>
<ul><li>Provide the proper recovery image for that device model.</li>
<li>Describe the recovery procedure specific to that device model. For example, if the device has a SD card but no USB port, the recovery procedure would indicate that a SD card is necessary, and would not discuss the possibility of recovering using USB.</li>
<li>Display graphics appropriate for the device model. For example, showing the location of the USB or SD card port.</li></ul>
</div>
</div>
<h3><a name="Users_should_be_able_to_manual"></a>
     Users must be able to manually trigger recovery mode</h3>
<div>
    If the writable firmware and/or rootfs have valid signatures but don't work (for example, the user somehow managed to get an ARM kernel on an x86 device), the user needs to be able to force recovery mode to run.
  </div>
<div>
<br />
</div>
<div>
    This can be done by having a physical reset button somewhere on the device. When this button is pressed during power-on, the device goes straight to the recovery firmware without even looking at the writable firmware or file system.</div>
<div><br />
</div>
<div>Some options for the recovery button:</div>
<div>
<ul><li>It could be a button attached to a GPIO on the main processor. In this case, the boot stub would initialize the GPIO and read its state at boot time.</li>
<li>It could be a button attached to a subprocessor such as the Embedded Controller (EC). In this case, the boot stub would need to request the button state from the EC at boot time.</li>
<li>It could be one of the keys on the keyboard, though this creates the undesirable possibility of accidentally entering recovery mode. </li>
<ul><li>This is undesirable if the only interface to the keyboard is USB, because USB firmware is more complex and the USB hardware interface can take a significant amount of time to initialize. </li>
<li>Some devices use a subprocessor to read the keyboard. In this case, initiating recovery mode is much like the previous option.</li>
<li>The keyboard could bring out the press-state of one of its keys to a separate I/O line, which could be attached to a GPIO on the processor or to a subprocessor.</li></ul></ul>
<div>Since the recoverability of Chromium OS is one of its key features, we seek to have a dedicated "recovery mode" button.</div>
</div>
<h3><a name="Support_developers_l33t_users_"></a>
     Support developers / l33t users installing their own software
  </h3>
</div>
<div>
  To provide a relatively trustable boot for the majority of users, we need to control all the read-only firmware at the beginning of the boot process.
</div>
<br />
<div>
  To support developers, at some point during the boot process, we need to hand off to code self-signed by someone else.</div>
<div><br />
</div>
<div>The initial devices will allow hand off at the point the kernel is loaded and its embedded signature is checked.  This can produce one of three results:</div>
<div>
<ul><li>Trusted kernel: The kernel has a valid signature, and the signing key is known to the firmware.  This is the normal case for production devices.</li>
<li>Developer kernel: The kernel has a valid signature, but the key used to sign the kernel is not known to the firmware.  This is the case when a developer builds and self-signs their own kernel.</li>
<li>Corrupt kernel: The kernel fails its signature check.</li></ul>
<p>Once the chain of trust departs from the standard Chromium OS boot chain, we need to indicate this clearly to the user of the device. This prevents malicious attackers from giving users a modified version of Chromium OS without the user knowing. We likely will need to show a warning screen which includes the following elements:</p>
</div>
</div>
<div style="margin-top:0px;margin-bottom:0px">
<ul style="margin-top:0px;margin-bottom:0px"><li>A warning that the standard image of Chromium OS is not running</li>
<li>A means of reverting back to the standard Chromium OS image</li>
<li>A means of allowing the user/developer to proceed down the "untrusted" path</li></ul>
<div><br />
</div>
<div>It is desirable for the warning screen to have a timeout, so that Chromium OS devices with developer images can be used in unattended applications (for example, as a media server).  The timeout should be sufficiently long that a user can read and respond to it - for example, at least 30 seconds.</div>
<div><br />
</div>
<div>Since language settings will not be available at this stage of the boot process, any messaging will likely need to be internationalized and displayed in all possible languages.</div>
</div>
<div>
<div>
<h2><a name="EEPROM_Map_19483716413378716_0_8527987941869014"></a>
    EEPROM map
  </h2>
<a name="EEPROM_Map"></a>
<div>Here is an early guess at sizes and layout of the EEPROM. These sizes may change as we progress with implementation.<br />
<br />
<div style="display:block;text-align:left"><a href="http://sites.google.com/a/chromium.org/dev/chromium-os/chromiumos-design-docs/firmware-boot-and-recovery/eeprom-map.png?attredirects=0" imageanchor="1"><img border="0" src="https://www.chromium.org/_/rsrc/1258650191714/chromium-os/chromiumos-design-docs/firmware-boot-and-recovery/eeprom-mappng" /></a></div>
</div>
<div><h2><a name="TOC-Firmware-block-descriptions"></a>Firmware block descriptions</h2>
</div>
<h3><a name="Boot_Stub_2175902035087347_738"></a>
     Boot stub
  </h3>
<div>
    Must be at the top of EEPROM, since most processors jump to the top of memory (0xFFFFFFF0) after internal initialization.
  </div>
<div>
<br />
</div>
<div>
    Contains the "root key" - the official public key used to verify the signature of the next stage of firmware. The private key is not contained on the device, and must be protected from all unauthorized access. To reduce exposure of the private root key, the private root key will be used to sign a second date-limited or numbered key stored in the rewritable firmware, which is then used to sign that firmware. Validation of the date or key number could be done via a TPM module.<br />
</div>
<div>
<br />
</div>
<div>
<b>Pseudocode</b></div>
<div>
<ol>
<li>
        Initialize processor and RAM (and implicitly, those parts of the north bridge necessary to initialize RAM), using conservative timings.
      </li>
<li>
        If user-forced recovery mode, skip to attempt loading recovery firmware. (The recovery button asserts an I/O line that can be measured by the firmware.)
      </li>
<li>Check the non-volatile register or memory region for a recovery mode cookie value.  If this is set, some later stage of the boot process must have failed and requested recovery mode, so skip to attempt loading recovery firmware.</li>
<li>
        Attempt loading Firmware A.</li>
<ol>
<li>
          Copy Firmware A to RAM.
        </li>
<li>
          Verify signature of Firmware A using public key stored in boot stub.</li>
<li>
          If signature is valid, jump to Firmware A Setup.
        </li>
</ol>
<li>
        Firmware A is bad. Repeat for Firmware B.
      </li>
<li>
        Both A and B are bad. Attempt loading recovery firmware to RAM and verify signature. If valid, jump to recovery firmware.
      </li>
<li>
        All recovery options have been exhausted. Catch fire / emit POST code / etc.</li>
</ol>
<h3><a name="Firmware_A_B_Setup_41671303566"></a>
       Firmware (A/B) setup</h3>
<div>This firmware sets up a minimal set of hardware components so that the boot loader can load the kernel from the normal boot drive.  For example, the SATA or eMMC controller.</div>
<div><br />
</div>
<div><b>Pseudocode</b></div>
</div>
<ol>
<li>Initialize chipset / file system sufficiently to jump to Boot Loader code.</li>
<li>
      Jump to Boot Loader code.</li>
</ol>
<div>
<div>
</div>
</div>
<h3><a name="Firmware_A_B_Bootstrap_6854730_9843585162384771"></a>
     Firmware (A/B) boot loader</h3>
<div>
    The boot loader is only designed to load Chromium OS. We can go directly from firmware bootstrap to the kernel in the disk.</div>
<div><br />
</div>
<div>
<b>Pseudocode</b></div>
<div><b>
<ol style="list-style-type:decimal"><li><span style="font-weight:normal">Verify the partition table on the disk looks sane.</span></li>
<li><span style="font-weight:normal">Load kernel A from the disk.</span></li>
<li><span style="font-weight:normal">Verify signature of kernel.</span></li>
<li><span style="font-weight:normal">If signature is invalid:</span></li>
<ol style="list-style-type:decimal"><li><span style="font-weight:normal">If this is kernel A, retry with kernel B.<br /></span>
</li>
<li><span style="font-weight:normal">Else this is kernel B.  Both kernels are bad, so set the recovery-mode cookie non-volatile register and reboot into recovery firmware.<br /></span>
</li>
</ol>
<li><span style="font-weight:normal">If kernel was signed with a public key not known to the boot loader, this is a developer kernel:</span></li>
<ol style="list-style-type:decimal"><li><span style="font-weight:normal">Initialize the display.</span></li>
<li><span style="font-weight:normal">Display scary developer mode warning to user. For example: "Google Chrome OS is not installed.  Press space bar to repair."</span></li>
<li><span style="font-weight:normal">Wait for keypress or 30-second delay before continuing.</span></li>
<li><span style="font-weight:normal">If key pressed was Space bar, Enter, or Esc, jump to Recovery Firmware.</span></li><li><span style="font-weight:normal">If key pressed was Control+D, dismiss screen.</span></li><li><span style="font-weight:normal">Ignore other key presses.</span></li>
</ol>
<li><span style="font-weight:normal">Continue booting the kernel.</span></li>
</ol>
</b></div>
<h3><a name="Boot_Log_909660461358726_02223_241900222824606"></a>Boot log</h3>
<div>A boot log will be stored at the bottom of the writable section of firmware. This will store the following types of events:
  </div>
<div>
<ul><li>Each time recovery firmware is run, with information on what triggered it (manual, bad firmware, bad root filesystem, etc.).</li>
<li>When a recovery completes, including which actions were taken.</li></ul>
<div>It does not store information on successful boots. This removes the need to support EEPROM writing in the normal boot process, and conserves space for log entries dealing with real errors.</div>
<div><br />
</div>
<div>The boot log can be uploaded as part of the autoupdate process. It can then be cleared and reused for new log entries.</div>
</div>
<h3><a name="Recovery_Firmware_325963526964_9310128691004004"></a>
     Recovery firmware
  </h3>
<div>
    This firmware attempts to recover from bad firmware or rootfs by loading a recovery image off an external storage device.
  </div>
<div>
<br />
</div>
<b>
  Pseudocode</b><br />
<ol>
<li>Write a log entry to the boot log indicating why recovery mode was activated (manual, bad writable firmware, user triggers recovery mode, etc.)</li>
<li>
      Initialize enough of the chipset to be able to access a storage device (USB drive, SD card, etc.)
    </li>
<li>Check for an inserted storage device.  If no storage device is present, skip to displaying recovery instructions.</li>
<li>Verify the signature of the recovery image, using a public key stored in the recovery firmware.  If the signature is invalid, skip to displaying recovery instructions.</li>
<li>Load and run the recovery image.</li>
<li>If we're still here, either no storage device was inserted, or the storage device did not contain a valid image.  Display recovery instructions:</li>
<ol><li>Initialize the display.</li>
<li>Display instructions.  These instructions must be internationalized and rendered in multiple languages.  The instructions must include:</li>
</ol>
<ul>
<ul><li>A warning that the computer is in recovery mode</li>
<li>How to obtain a trusted recovery image (for example, instructions to go to a second computer and browse to a specified URL for further instructions)</li><li>An indication if an already-inserted storage device does not contain a valid recovery image (sorry, try again).</li></ul></ul>
<li>Wait for a storage device to be inserted, then go back to step 3.</li>
</ol>
</div>
<div>Most of the recovery work is left to the recovery image loaded from the storage device. This allows for publishing updated recovery images and instructions. Because the recovery firmware is etched in stone (well, as electrons in floating gates) at the time the device is launched, it needs to be as simple and robust as possible.</div>
<div>
<h2><a name="Recovery_Image_999069100245833_9862531434570179"></a>
     Recovery image
  </h2>
<a name="Recovery_Image"></a>
<div>
    This is the software loaded onto a storage device (USB drive, SD card, etc.) which does the bulk of the recovery work.
  </div>
<div>
<br />
</div>
<div>The recovery image will be available for download. </div>
<div><br />
</div>
<div>We will need to provide a downloadable installer for users to use to install the recovery image on the storage device. This installer should be supplied for all popular operating systems (Chromium OS, Windows, Mac OS X, Ubuntu Linux). The installer will:</div>
<div>
<ul><li>Prompt the user to select a destination for the recovery image<br />
</li>
<ul><li>Ideally, the user will only be able to select destination devices appropriate for recovery of the laptop model they are attempting to recover.</li><li>Also, the user should only be able to select removable devices. We don't want them trashing their hard disk.</li></ul>
<li>Warn the user that this will erase whatever is on that destination, and prompt for confirmation</li>
<li>Reformat the destination storage device</li>
<li>Install the recovery image on the storage device</li>
<li>Prompt the user to insert the storage device into the Chromium OS device</li></ul>
<div>Ideally, the installer would be able to back up the current data on the destination device, before reformatting and writing the recovery image. When recovery is complete, the user could re-insert the destination device and have the original contents restored.</div>
<div><br />
</div>
</div>
<div>The recovery image should contain an entire clean copy of the firmware and rootfs. This way, a user can make a recovery device ahead of time. For example, if a user is going to be somewhere with poor connectivity, they could make a recovery USB drive at home and keep it in their bag. Alternately, the system could come with a recovery device (though users might end up reformatting it and filling it with images of kittens).</div>
<div>
<div>
<div>
<br />
</div>
<div>
        The recovery image on the storage device would do something like the following:
      </div>
<div>
<ol>
<li>
            Initialize the display and tell the user what's going on. Reassure them that their Chromium OS system is trying to recover.
          </li>
<li>
            If developer firmware is detected, give the user a choice of "JUST FIX IT" or "Scary Settings for L33t H4x0rs". If the user picks the latter:
          </li>
<ol>
<li>
              Give the developer more control over each stage in the rest of the recovery. 
            </li>
<li>
              For example, a developer might not want to wipe and replace rootfs or stateful data, or might want to make a backup of that data.
            </li>
</ol>
<li>
            Run system tests. It's possible that the boot problems are due to bad hardware. Now's the time to detect that.
          </li>
<ol><li>If hardware is sufficiently bad that the rest of recovery can't be run, show the user information on how to return it.</li>
</ol>
<li>
            Verify both firmware A and firmware B are up-to-date and valid. Load known good firmware as needed.
          </li>
<li>
            Verify rootfs-A and rootfs-B are up-to-date and valid. Load known good rootfs images as needed.
          </li>
<li>Wipe the stateful data. Anything the user cares about should be in the cloud anyway. If the user's been hacked, wiping the data will put the device back in a known good state.
          </li>
<ol><li>Optionally, it can inform the user that data on the system will be erased.</li>
<li>This message should emphasize that most data is saved to the cloud, so that the user is more likely to proceed with recovery.</li>
<li>It is less desirable to give the user a choice whether or not to delete the stateful data. Most users would pick the less scary but also less secure option of NOT deleting data - but this leaves them vulnerable to persistent hacks on the data partition, such as manipulating their /etc/hosts file or bookmarks.</li>
</ol>
<li>If recovery mode was manually triggered, ask the user why they're running it.</li>
<ol><li>Couldn't even log in; crash during boot</li>
<li>Kept crashing after boot</li>
<li>Worried my system was hacked</li>
<li>Hey, what's this button do?</li>
</ol>
<li>Write an entry to the boot log describing repairs performed.</li>
</ol>
</div>
<div>
<h3><a name="Recovery_via_Chrome_OS_2183209_6000941713093587"></a>Recovery via Chromium OS</h3>
<div>The recovery installer should run on a healthy Chromium OS system. That is, it should be able to download the recovery image, reformat the storage device, and copy the recovery image to it. </div>
<div>
<ul><li>This enables a healthy Chromium OS system to create its own recovery device in advance. </li>
<ul><li>Perhaps we should periodically advise users to update their recovery device?</li></ul>
<li>It also enables one Chromium OS system to download a recovery image for a different model. (A user has a corrupt system, so they go to their friend's house and use the friend's Chromium OS system to make a recovery image).</li></ul>
</div>
<h3><a name="Making_Recovery_Images_Read_On"></a>
           Making recovery images read-only
        </h3>
<div>
          If the recovery image is inserted into a powered-on and hacked system, the hacked software could delete or corrupt it. This won't cause the recovery firmware to load that corrupt image, because the corrupt image will fail the signature check. It will be annoying to the user, who will need to reflash the storage device.</div>
<div><br />
</div>
<div>
          This is more of an issue if we want to include an internal recovery image (for example, on an internal storage device).
        </div>
<div>
<br />
</div>
<div>
          The SD standard specifies a physical write-protect notch for SD cards, similar to those on a 3.5" floppy disk. Unfortunately, the implementation of the write-protection is purely software, so pwned drivers can choose to ignore the write-protect detect signal.
        </div>
<div>
<br />
</div>
</div>
</div>
</div>
  Some USB drives have a write-protect switch on them. In this case, the protection is handled by the USB drive itself.
</div>
<div>
<br />
</div>
<div>
  Some eMMC chips have a number of protection mechanisms including:</div>
<div>
<ul>
<li>
      an external LOCK# pin which can be used to make the device read-only
    </li>
<li>
      a write-once bit which makes the device read-only until reboot
    </li>
</ul>
</div>
<div>
  Since these chips come in sizes up to 2GB (~$10 at stores), they provide a possible place to store a recovery image. Some system architectures may be able to use the eMMC drive to hold the main firmware image also.<br />
<div>
<br />
</div>
<div>
    If we have an internal storage device, it's possible we could wire it so it's only enabled if the recovery button is pressed at boot time. For example, we could use that button to latch up a circuit which powers that device, so that it will remain powered during that boot only.
  </div>
<h3><a name="Using_Recovery_Mode_to_load_De"></a>Using recovery mode to load developer mode firmware/software</h3>
<div>If the rootfs image on the SD card is signed by someone else, the recovery image will display a screen similar to the Developer Mode screen.  Instructions on this screen should include:</div>
<div>
<ul><li>Notice that the recovery image is signed by someone else</li>
<li>How to obtain a trusted recovery mode image</li>
<li>Instructions on installing a trusted recovery image</li>
<li>A means of allowing the user/developer to proceed down the "untrusted" path</li></ul>
</div>
<div>
<div>Note that this screen must also be internationalized / rendered in multiple languages. This is potentially much easier, since by the time we're doing this the recovery image has booted a full OS with GUI.</div>
</div>
<h2><a name="Boot_Flowchart_033826657570898"></a>Boot flowchart</h2>
<div>The three main downward flows in this chart show:</div>
<div>
<ul><li>Start of boot in read-only firmware</li>
<li>Normal continuation of boot, loading kernel from internal drive</li>
<li>Recovery mode</li></ul><div style="display:block;text-align:left"><a href="https://www.chromium.org/chromium-os/chromiumos-design-docs/firmware-boot-and-recovery/ChromeOSFirmwareBootandRecoveryPUBLISHED.png?attredirects=0" imageanchor="1"><img border="0" src="https://www.chromium.org/_/rsrc/1277241373652/chromium-os/chromiumos-design-docs/firmware-boot-and-recovery/ChromeOSFirmwareBootandRecoveryPUBLISHED.png" /></a></div>
<div style="display:block;text-align:left"></div><h2><a name="TOC-Other-notes"></a>Other notes</h2>
</div>
<h3><a name="Verification_of_the_Rest_of_ro"></a>
     Verification of the rest of the rootfs
  </h3>
<div>
    The firmware boot process above describes a way to verify all code from the start of boot through hand off to the kernel. 
  </div>
<div>
<br />
</div>
<div>
    The kernel is responsible for verifying the rest of the data in the rootfs - for example, user-mode drivers. If the kernel determines that the rootfs has been compromised, it can force recovery mode to run by setting the recovery mode cookie in a non-volatile register and rebooting into recovery mode.</div>
<div><br />
</div>
<div>Alternately, a kernel which determines its rootfs is corrupt can commit suicide by marking its partition as inactive and then rebooting. The next boot will do one of the following:</div>
<div>
<ul><li>If the other root partition is good, the boot loader will run the other root partition.</li>
<li>If neither root partition is good, the boot loader will trigger the recovery mode firmware, which can put the rootfs back in a known state.</li></ul>
</div>
<div>
<h3><a name="When_to_Verify_the_Boot_Proces"></a>
      When to verify the boot process
    </h3>
<div>We should develop under the initial assumption that we can verify every boot, since this provides the most security. </div>
<div><br />
</div>
<div>Signature-checking code does impact startup time. However, this is likely not an issue for the firmware (&lt; 1 MB) and kernel (&lt; 10 MB) than it is for the remainder of the rootfs. We assume that we will verify the entire firmware and kernel every boot.</div>
</div>
</div>
<h3><a name="Handling_Returned_Netbooks_578"></a>Handling returned systems</h3>
When a Chromium OS system is returned to the store, the store should check to make sure it still boots.</div>
<div>
<ul><li>If it boots normally, the store can follow their standard process for dealing with returns.</li>
<li>If it displays the Scary Dev Mode screen, the store can either run recovery mode or refuse the return (in which case the original owner can go home and run recovery mode, then come back and returns the system again).</li>
<li>If it fails to boot, it gets shipped back to the manufacturer.<br />
</li></ul>
<div>Note that it's advisable for stores to run recovery mode on returned computers anyway, to put them back into a clean state and destroy any user data still on the device.</div>
<h3><a name="Testing_17694905913316072_043226863012933325"></a>Testing</h3>
</div>
<div>The comprehensive test suite for Chromium OS should include tests of each stage of the verification process and the recovery procedure, including all decision points in the pseudocode/flowchart. This will require actual hardware for each firmware image being tested.</div>
<div><br />
</div>
<div>Testing should also attempt to write to the read-only portion of the EEPROM, to ensure that it is in fact not writable.</div>
<div>
<h2><a name="Open_Issues_6727640628814697_9"></a>Open issues</h2>
<h3><a name="What_Else_Do_We_Need_To_Verify"></a>
  What else do we need to verify?
</h3>
<div>
  This document describes verifying the following:
</div>
<div>
<ul>
<li>
      Firmware in the main EEPROM
    </li>
<li>
      Partition table
    </li><li>The kernel partition</li>
</ul>
</div>
<div>
  It explicitly does not discuss verifying:
</div>
<div>
<ul>
<li>
      The rootfs (anything after the hand off to the kernel)
    </li>
<li>The stateful data partition</li>
</ul>
</div>
<div>
  Are there other locations for persistent storage we should be verifying? For example:
</div>
<div>
<ul>
<li>
      Firmware in other components?
    </li>
<ul>
<li>
        File system</li>
<li>
        NIC
      </li>
<li>
        3G modem
      </li>
<li>Embedded controller</li>
<li>Modem processor (on ARM systems)</li>
<li>
        Keyboard (<a href="http://www.engadget.com/2009/08/04/apple-keyboard-gets-hacked-like-a-ripe-papaya-perp-caught-on-vi" target="_blank" title="this apparently is an attack surface on some systems">this apparently is an attack surface on some systems</a>)
      </li>
<li>(we disallow option ROMs in the hardware spec, so we don't need to worry about those)</li>
</ul>
<li>Removable user media</li>
</ul>
</div>
<h3><a name="Can_we_log_firmware_crashes_54_8565273169739532"></a>Can we log firmware crashes? </h3>
<div>
<ul><li>Crashes in boot stub (i.e., north bridge / RAM init) likely aren't loggable at all. Not enough of the system is running.<br />
</li>
<li>Other crashes in the firmware could write a cookie into a particular address in SDRAM. </li>
<ul><li>When the system boots next, it could check that address for a valid crash cookie. </li>
<li>If so, assume the current firmware is bad; try the backup firmware, or go to recovery mode.</li>
<li>Downside: Intermittent crashes which would be mildly annoying now prevent the system from attempting to boot at all, since it would tend to go into recovery mode.</li></ul>
<li>Crashes in the kernel can be logged to the stateful partition.</li></ul>
</div>
<h3><a name="Chain_of_verification_on_ARM_2_45279574090983055"></a>Chain of verification on ARM?</h3>
<div>Some ARM SOCs contain a modem processor and an application processor. On boot, only the modem processor is running; its firmware then sets up and starts the application processor. If the modem firmware is writable, we could be hacked before the first instruction of our firmware executes. We need a way to secure the modem firmware. (This is true regardless of the boot order, if the modem firmware has access to the registers or RAM used by the application processor). <br />
</div>
<div><br />
</div>
<div>Such systems could use a Memory Protection Unit or similar such hardware solution, to prevent the modem and application processors from reading/writing each other's firmware or memory space, except for specific portions of the memory space used for inter-processor communication. We are still investigating what solutions can be used for verified boot.</div>
</div>
<h3><a name="Support_for_Trusted_Platform_M_472807140635382"></a>Support for Trusted Platform Module (TPM)?</h3>
<div>A TPM is not required for key verification for the firmware boot and recovery process described in this document. There's no point in the verification key being more secure than the code in ROM used to do the verification.  If an attacker can crack the ROM code, they can just make it bypass the TPM check.</div>
<div><br />
</div>
If the boot stub contains a secondary key which is date-limited, it is desirable to use the TPM to verify the date-limited key is valid. Many TPM modules contain their own clock/counter, so can be used to defend against turn-back-the-clock attacks.  Similarly, if we use numbered or sequential secondary keys, storing the highest-seen key number in the TPM can protect against rollback attacks.
<div><br />
<div>There may be some firmware requirements to set up the TPM so that subsequent activities (3G authentication, etc.) can get access to the keys stored in the TPM.</div>
</div></div></td></tr></tbody></table>
</div> 
</div> 
<div id="sites-canvas-bottom-panel">
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_page-subpages"> </div>
<div id="sites-attachments-container">
<div xmlns="http://www.w3.org/1999/xhtml" id="sites-attachments">
<div class="sites-attachments-row"><div class="sites-attachments-icon" style="left:0px;"><span aria-label="Attachments" title="Attachments"><div class="sites-translucent sites-symbol" aria-hidden="true">Č</div></span></div><div id="sites-attachments-update-div" class="sites-attachments-inner-div" style="display:none;"><span class="sites-attachments-update-icon"><img src="https://ssl.gstatic.com/sites/p/56e332/system/app/images/spinner.gif" /></span><div class="sites-attachments-update-text">Updating...</div></div></div><div class="sites-attachments-separator"></div>
<div id="attachment-wuid:gx:7f73bd1c4434d399"><div class="sites-attachments-row"><div class="sites-attachments-icon sites-attachments-icon-accessible" style="left:5px"><div class="sites-translucent sites-symbol" aria-label="File" title="File">ċ</div></div><div class="sites-attachments-inner-div"><div class="sites-attachments-name">eeprom-mappng <div class="sites-translucent">(15k)</div></div><div class="sites-attachments-author">Jed Hartman, <div class="sites-translucent">Nov 19, 2009, 9:03 AM</div></div></div><div class="sites-attachments-version sites-attachments-version-accessible"><a href="https://www.chromium.org/system/app/pages/admin/revisions?wuid=wuid:gx:7f73bd1c4434d399">v.1</a></div><div id="attachment-download-wuid:gx:7f73bd1c4434d399" class="sites-attachments-icon sites-attachments-icon-accessible" style="right:0px"><a href="https://www.chromium.org/chromium-os/chromiumos-design-docs/firmware-boot-and-recovery/eeprom-mappng?attredirects=0&amp;d=1" aria-label="Download eeprom-mappng" title="Download" role="button"><span class="sites-symbol" aria-hidden="true">ď</span></a></div></div><div class="sites-attachments-separator"></div></div>
<div id="attachment-wuid:gx:65e9b5dbe8fecb77"><div class="sites-attachments-row"><div class="sites-attachments-icon sites-attachments-icon-accessible" style="left:5px"><div class="sites-translucent sites-symbol" aria-label="File" title="File">ċ</div></div><div class="sites-attachments-inner-div"><div class="sites-attachments-name">flowchart1png <div class="sites-translucent">(60k)</div></div><div class="sites-attachments-author">Jed Hartman, <div class="sites-translucent">Nov 19, 2009, 9:03 AM</div></div></div><div class="sites-attachments-version sites-attachments-version-accessible"><a href="https://www.chromium.org/system/app/pages/admin/revisions?wuid=wuid:gx:65e9b5dbe8fecb77">v.1</a></div><div id="attachment-download-wuid:gx:65e9b5dbe8fecb77" class="sites-attachments-icon sites-attachments-icon-accessible" style="right:0px"><a href="https://www.chromium.org/chromium-os/chromiumos-design-docs/firmware-boot-and-recovery/flowchart1png?attredirects=0&amp;d=1" aria-label="Download flowchart1png" title="Download" role="button"><span class="sites-symbol" aria-hidden="true">ď</span></a></div></div><div class="sites-attachments-separator"></div></div>
<div style="height: 10px"></div>
</div>
</div>
<a xmlns="http://www.w3.org/1999/xhtml" name="page-comments"></a>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_page-comments"><div class="sites-comment-docos-wrapper"><div class="sites-comment-docos"><div class="sites-comment-docos-background"></div><div class="sites-comment-docos-header"><div class="sites-comment-docos-header-title">Comments</div></div><div id="sites-comment-docos-pane" class="sites-comment-docos-pane"></div></div></div></div>
</div>
</div> 
</td> 
</tr>
</table> 
</div> 
</div> 
<div id="sites-chrome-footer-wrapper">
<div id="sites-chrome-footer-wrapper-inside">
<div id="sites-chrome-footer">
</div>
</div>
</div>
</div> 
</div> 
<div id="sites-chrome-adminfooter-container">
<div xmlns="http://www.w3.org/1999/xhtml" class="sites-adminfooter" role="navigation"><p><a class="sites-system-link" href="https://www.google.com/a/UniversalLogin?service=jotspot&amp;continue=https://sites.google.com/a/chromium.org/dev/chromium-os/chromiumos-design-docs/firmware-boot-and-recovery">Sign in</a><span aria-hidden="true">|</span><a class="sites-system-link" href="../../system/app/pages/recentChanges.html">Recent Site Activity</a><span aria-hidden="true">|</span><a class="sites-system-link" href="../../system/app/pages/reportAbuse.html" target="_blank">Report Abuse</a><span aria-hidden="true">|</span><a class="sites-system-link" href="javascript:;" onclick="window.open(webspace.printUrl)">Print Page</a><span aria-hidden="true">|</span><span class="sites-system-link">Powered By</span> <b class="powered-by"><a href="http://sites.google.com">Google Sites</a></b></p></div>
</div>
</div> 
</div> 
<div id="sites-chrome-onebar-footer">
</div>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    window.jstiming.load.tick('sjl');
  </script>
<script xmlns="http://www.w3.org/1999/xhtml" src="https://ssl.gstatic.com/sites/p/56e332/system/js/jot_min_view__en.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    window.jstiming.load.tick('jl');
  </script>
<script xmlns="http://www.w3.org/1999/xhtml">
      
          sites.core.Analytics.createTracker();
          sites.core.Analytics.trackPageview();
        
    </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
                    sites.Searchbox.initialize(
                        'sites-searchbox-search-button',
                        {"object":[]}['object'],
                        'search-site',
                        {"label":"Configure search options...","url":"/system/app/pages/admin/settings"});
                  </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
      gsites.HoverPopupMenu.createSiteDropdownMenus('sites-header-nav-dropdown', false);
    </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" defer="true">
            JOT_setupNav("7648876402527094", "Navigation", false);
            JOT_addListener('titleChange', 'JOT_NAVIGATION_titleChange', 'COMP_7648876402527094');
          </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" defer="true">
            JOT_setupNav("14720868319272995", "Quick links", false);
            JOT_addListener('titleChange', 'JOT_NAVIGATION_titleChange', 'COMP_14720868319272995');
          </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" defer="true">
            JOT_setupNav("19690813310444355", "Other sites", false);
            JOT_addListener('titleChange', 'JOT_NAVIGATION_titleChange', 'COMP_19690813310444355');
          </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
              new sites.CommentPane('//docs.google.com/comments/d/AAHRpnXvrAwjAfmld0ObrebBiGRq9Il2j4ikTIhxQh2PFo6eo2FxZf1rcHIg7dK9stLuX99P8rwRKi-jpDIQHu9LAL-WLiKFUqhLJZp1oT20nZ1_mYhGxXAtAmln6E9Bq7uaVnCf8af-u/api/js?anon=true',
                  false, false);
            </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
  setTimeout(function() {
    var fingerprint = gsites.date.TimeZone.getFingerprint([]);
    gsites.Xhr.send('https://www.chromium.org/_/tz', null, null, 'GET', null, null, { afjstz: fingerprint });
  }, 500);
</script>
<script xmlns="http://www.w3.org/1999/xhtml">
                    window.onload = function() {
                      if (false) {
                        JOT_setMobilePreview();
                      }
                      var loadTimer = window.jstiming.load;
                      loadTimer.tick("ol");
                      loadTimer["name"] = "load," + webspace.page.type + ",user_page";
                      window.jstiming.report(loadTimer, {}, 'https://gg.google.com/csi');
                    }
                  </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
        JOT_insertAnalyticsCode(false,
            false);
      </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    var maestroRunner = new gsites.pages.view.SitesMaestroRunner(
        webspace, "en");
    maestroRunner.initListeners();
    maestroRunner.installEditRender();
  </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" defer="true">
  //<![CDATA[
    // Decorate any fastUI buttons on the page with a class of 'goog-button'.
    if (webspace.user.hasWriteAccess) {
      JOT_decorateButtons();
    }

    // Fires delayed events.
    (function() {
      JOT_fullyLoaded = true;
      var delayedEvents = JOT_delayedEvents;
      for (var x = 0; x < delayedEvents.length; x++) {
        var event = delayedEvents[x];
        JOT_postEvent(event.eventName, event.eventSrc, event.payload);
      }
      JOT_delayedEvents = null;
      JOT_postEvent('pageLoaded');
    })();
  //]]>
</script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    JOT_postEvent('decorateGvizCharts');
  </script>
<script type="text/javascript">
          JOT_setupPostRenderingManager();
        </script>
<script type="text/javascript">
          JOT_postEvent('renderPlus', null, 'sites-chrome-main');
        </script>
<div id="server-timer-div" style="display:none"> </div>
<script type="text/javascript">
          window.jstiming.load.tick('render');
          JOT_postEvent('usercontentrendered', this);
        </script>
</body>
</html>
